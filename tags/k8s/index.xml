<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>k8s on KungFu Developer</title>
    <link>https://www.kungfudev.com/tags/k8s/</link>
    <description>Recent content in k8s on KungFu Developer</description>
    <image>
      <url>https://www.kungfudev.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://www.kungfudev.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Fri, 16 Dec 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://www.kungfudev.com/tags/k8s/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>A simple example of using unix domain socket in Kubernetes</title>
      <link>https://www.kungfudev.com/posts/simple-example-of-using-unix-domain-socket-in-kubernetes/</link>
      <pubDate>Fri, 16 Dec 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.kungfudev.com/posts/simple-example-of-using-unix-domain-socket-in-kubernetes/</guid>
      <description>In my previous post, Understanding Unix Domain Sockets in Golang, I mentioned that one potential use case for Unix domain sockets is to communicate between containers in Kubernetes. I received requests for an example of how to do this, so in this post, I&amp;rsquo;ll provide a simple example using two Go applications that you can find in this repository.
Using Unix domain sockets in Kubernetes can be an effective way to communicate containers within the same pod.</description>
    </item>
    
    <item>
      <title>CEL for admission controller with ValidatingAdmissionPolicy in K8s 1.26</title>
      <link>https://www.kungfudev.com/posts/cel-for-admission-controller/</link>
      <pubDate>Fri, 16 Dec 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.kungfudev.com/posts/cel-for-admission-controller/</guid>
      <description>The Kubernetes crew just dropped the latest version, k8s 1.26 a few days ago, and it&amp;rsquo;s packed with some seriously cool new features. One that&amp;rsquo;s catching my eye is CEL for admission control - it allows us to create a ValidatingAdmissionPolicy, taking our cluster security to the next level.
Validating admission policies offer a declarative, in-process alternative to validating admission webhooks.
Validating admission policies use the Common Expression Language (CEL) to declare the validation rules of a policy.</description>
    </item>
    
    <item>
      <title>Implementing a simple K8s admission controller in Go</title>
      <link>https://www.kungfudev.com/posts/implementing-k8s-admission-controller/</link>
      <pubDate>Mon, 01 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.kungfudev.com/posts/implementing-k8s-admission-controller/</guid>
      <description>What is an admission controller? In a nutshell, Kubernetes admission controllers are plugins that govern and enforce how the cluster is used. They can be thought of as a gatekeeper that intercept (authenticated) API requests and may change the request object or deny the request altogether. The admission control process has two phases: the mutating phase is executed first, followed by the validating phase.
Kubernetes admission Controller Phases:
An admission controller is a piece of software that intercepts requests to the Kubernetes API server before the persistence of the object (the k8s resource such as Pod, Deployment, Service, etc&amp;hellip;) in the etcd database, but after the request is authenticated and authorized.</description>
    </item>
    
    <item>
      <title>How to setup simple load balancing with IPVS, demo with docker</title>
      <link>https://www.kungfudev.com/posts/how-to-setup-simple-load-balancing-with-ipvs-demo-with-docker/</link>
      <pubDate>Mon, 06 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.kungfudev.com/posts/how-to-setup-simple-load-balancing-with-ipvs-demo-with-docker/</guid>
      <description>A few days ago, I was reading about the Kubernetes network model, especially about services and the kube-proxy component, and I discovered that kube-proxy has three modes, which are userspace, iptables and ipvs.
The userspace mode is too old and slow, nowaday nobody recommends to use it, the iptables mode is the default mode for kube-proxy with this mode kube-proxy use iptables rules to forward packets that are destined for services to a backend for that services, and the last one is ipvs I did not know what it was so I read about it.</description>
    </item>
    
  </channel>
</rss>

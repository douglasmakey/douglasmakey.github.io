<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>linux on KungFu Developer</title>
    <link>https://www.kungfudev.com/tags/linux/</link>
    <description>Recent content in linux on KungFu Developer</description>
    <image>
      <url>https://www.kungfudev.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://www.kungfudev.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Fri, 16 Dec 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://www.kungfudev.com/tags/linux/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>A simple example of using unix domain socket in Kubernetes</title>
      <link>https://www.kungfudev.com/posts/simple-example-of-using-unix-domain-socket-in-kubernetes/</link>
      <pubDate>Fri, 16 Dec 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.kungfudev.com/posts/simple-example-of-using-unix-domain-socket-in-kubernetes/</guid>
      <description>In my previous post, Understanding Unix Domain Sockets in Golang, I mentioned that one potential use case for Unix domain sockets is to communicate between containers in Kubernetes. I received requests for an example of how to do this, so in this post, I&amp;rsquo;ll provide a simple example using two Go applications that you can find in this repository.
Using Unix domain sockets in Kubernetes can be an effective way to communicate containers within the same pod.</description>
    </item>
    
    <item>
      <title>Understanding Unix Domain Sockets in Golang</title>
      <link>https://www.kungfudev.com/posts/understanding-unix-domain-sockets-in-golang/</link>
      <pubDate>Mon, 05 Dec 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.kungfudev.com/posts/understanding-unix-domain-sockets-in-golang/</guid>
      <description>In Golang, a socket is a communication endpoint that allows a program to send and receive data over a network. There are two main types of sockets in Golang: Unix domain sockets (AF_UNIX) and network sockets (AF_INET|AF_INET6). This blog post will explore some differences between these two types of sockets.
Unix domain sockets, a.k.a., local sockets, are used for communication between processes on the same machine. They use a file-based interface and can be accessed using the file system path, just like regular files.</description>
    </item>
    
    <item>
      <title>Socket sharding in Linux example with Go</title>
      <link>https://www.kungfudev.com/posts/socket-sharding-go/</link>
      <pubDate>Sat, 21 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.kungfudev.com/posts/socket-sharding-go/</guid>
      <description>I bet there have been many times that you were working on the terminal with multiple tabs and you launched an HTTP server, and then you forgot that the server was already being executed, and then you tried to relaunch it from another tab getting the known error:
go run main.go listen tcp :8080: bind: address already in use This is because we cannot open a socket with the same source address and port by default in Linux and the vast majority of operating systems.</description>
    </item>
    
    <item>
      <title>How to setup simple load balancing with IPVS, demo with docker</title>
      <link>https://www.kungfudev.com/posts/how-to-setup-simple-load-balancing-with-ipvs-demo-with-docker/</link>
      <pubDate>Mon, 06 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.kungfudev.com/posts/how-to-setup-simple-load-balancing-with-ipvs-demo-with-docker/</guid>
      <description>A few days ago, I was reading about the Kubernetes network model, especially about services and the kube-proxy component, and I discovered that kube-proxy has three modes, which are userspace, iptables and ipvs.
The userspace mode is too old and slow, nowaday nobody recommends to use it, the iptables mode is the default mode for kube-proxy with this mode kube-proxy use iptables rules to forward packets that are destined for services to a backend for that services, and the last one is ipvs I did not know what it was so I read about it.</description>
    </item>
    
  </channel>
</rss>

<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Optimizing Large File Transfers in Linux with Go - An Exploration of TCP and Syscall | KungFu Developer</title><meta name=keywords content="go,linux,socket,network,unix"><meta name=description content="As I experiment with Raspberry Pi and other devices in my network, I have created a small network application to aid in device discovery using multicast, data collection, and other functions.
One key feature of this application is the ability to download various data and metrics from some plugins weekly. With file sizes ranging from 200 MB to 250 MB after applying some compression, it&rsquo;s essential to carefully consider some approaches for sending these files over TCP using Go."><meta name=author content="Me"><link rel=canonical href=https://www.kungfudev.com/posts/optimizing-large-file-transfer-linux-go/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://www.kungfudev.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.kungfudev.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.kungfudev.com/favicon-32x32.png><link rel=apple-touch-icon href=https://www.kungfudev.com/apple-touch-icon.png><link rel=mask-icon href=https://www.kungfudev.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://www.kungfudev.com/posts/optimizing-large-file-transfer-linux-go/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Optimizing Large File Transfers in Linux with Go - An Exploration of TCP and Syscall"><meta property="og:description" content="As I experiment with Raspberry Pi and other devices in my network, I have created a small network application to aid in device discovery using multicast, data collection, and other functions.
One key feature of this application is the ability to download various data and metrics from some plugins weekly. With file sizes ranging from 200 MB to 250 MB after applying some compression, it&rsquo;s essential to carefully consider some approaches for sending these files over TCP using Go."><meta property="og:type" content="article"><meta property="og:url" content="https://www.kungfudev.com/posts/optimizing-large-file-transfer-linux-go/"><meta property="og:image" content="https://www.kungfudev.com/img/naive-approach.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-01-30T00:00:00+00:00"><meta property="article:modified_time" content="2023-01-30T00:00:00+00:00"><meta property="og:site_name" content="I'm a Kung Fu Deveveloper"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.kungfudev.com/img/naive-approach.png"><meta name=twitter:title content="Optimizing Large File Transfers in Linux with Go - An Exploration of TCP and Syscall"><meta name=twitter:description content="As I experiment with Raspberry Pi and other devices in my network, I have created a small network application to aid in device discovery using multicast, data collection, and other functions.
One key feature of this application is the ability to download various data and metrics from some plugins weekly. With file sizes ranging from 200 MB to 250 MB after applying some compression, it&rsquo;s essential to carefully consider some approaches for sending these files over TCP using Go."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://www.kungfudev.com/posts/"},{"@type":"ListItem","position":3,"name":"Optimizing Large File Transfers in Linux with Go - An Exploration of TCP and Syscall","item":"https://www.kungfudev.com/posts/optimizing-large-file-transfer-linux-go/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Optimizing Large File Transfers in Linux with Go - An Exploration of TCP and Syscall","name":"Optimizing Large File Transfers in Linux with Go - An Exploration of TCP and Syscall","description":"As I experiment with Raspberry Pi and other devices in my network, I have created a small network application to aid in device discovery using multicast, data collection, and other functions.\nOne key feature of this application is the ability to download various data and metrics from some plugins weekly. With file sizes ranging from 200 MB to 250 MB after applying some compression, it\u0026rsquo;s essential to carefully consider some approaches for sending these files over TCP using Go.","keywords":["go","linux","socket","network","unix"],"articleBody":"As I experiment with Raspberry Pi and other devices in my network, I have created a small network application to aid in device discovery using multicast, data collection, and other functions.\nOne key feature of this application is the ability to download various data and metrics from some plugins weekly. With file sizes ranging from 200 MB to 250 MB after applying some compression, it’s essential to carefully consider some approaches for sending these files over TCP using Go.\nIn this article, we’ll explore some approaches and tips for sending large files over TCP in linux using Go, taking into account the constraints of small devices and the importance of efficient and reliable file transmission.\nNaive approach func sendFile(file *os.File, conn net.Conn) error { // Get file stat fileInfo, _ := file.Stat() // Send the file size sizeBuf := make([]byte, 8) binary.LittleEndian.PutUint64(sizeBuf, uint64(fileInfo.Size())) _, err := conn.Write(sizeBuf) if err != nil { return err } // Send the file contents by chunks buf := make([]byte, 1024) for { n, err := file.Read(buf) if err == io.EOF { break } _, err = conn.Write(buf[:n]) if err != nil { fmt.Println(\"error writing to the conn:\", err) break } } return nil } Although this code appears straightforward, it has a significant drawback regarding efficiency. The code moves data in a loop from the kernel buffer for the source to a buffer in user space and then immediately copies it from that buffer to the kernel buffer for the destination. This double copying of data results in a loss of performance as the buffer serves only as a temporary holding place.\nWhile increasing the buf size to minimize the number of system calls might seem like a viable solution, it actually results in an increase in memory usage, making it an inefficient approach for tiny devices.\nMoreover, the double copying of data also increases memory usage, as both the source and destination buffers must be allocated and maintained in memory. This can strain the system’s resources, particularly when transferring large files and the devices are small.\nThe below diagram provides a simplified illustration of data flow when sending files over TCP. Using the previous approach, it’s important to note that the data is copied four times before the process is complete:\nFrom the disk to the read buffer in the kernel space. From the read buffer in the kernel space to the app buffer in the user space. From the app buffer in the user space to the socket buffer in the kernel space. Finally, from the socket buffer in the kernel space to the Network Interface Controller (NIC). This highlights the inefficiency of copying data multiple times, that’s without mention the multiple context switches between user mode and kernel mode.\nThe data is copied from the disk to the read buffer in kernel space when a read() call is issued, and the copy is performed by direct memory access (DMA). This results in a context switch from user mode to kernel mode. The data is then copied from the read buffer to the app buffer by the CPU, which requires another context switch from kernel to user mode.\nWhen a write/send() call is made, another context switch from user mode to kernel mode occurs, and the data is copied from the app buffer to a socket buffer in kernel space by the CPU. Then, a fourth context switch occurs as the write/send() call returns. The DMA engine then passes the data to the protocol engine asynchronously.\nWhat is DMA?\nDMA stands for Direct Memory Access. It’s a technology that allows peripheral devices to access computer memory directly, without needing the CPU, to speed up data transfer. In this way, the CPU is freed from performing the data transfer itself, allowing it to perform other tasks and making the system more efficient. https://en.wikipedia.org/wiki/Direct_memory_access\nTo optimize the file transfer process, we have to minimize the number of buffer copies and context switches and reduce the overhead of moving data from one place to another.\nUsing a specialized syscall ‘sendfile’ Golang provides access to low-level operating system functionality through the syscall package, which contains an interface to various system primitives.\nfunc sendFile(file *os.File, conn net.Conn) error { // Get file stat fileInfo, _ := file.Stat() // Send the file size sizeBuf := make([]byte, 8) binary.LittleEndian.PutUint64(sizeBuf, uint64(fileInfo.Size())) if _, err := conn.Write(sizeBuf); err != nil { return err } tcpConn, ok := conn.(*net.TCPConn) if !ok { return errors.New(\"TCPConn error\") } tcpF, err := tcpConn.File() if err != nil { return err } // Send the file contents _, err = syscall.Sendfile(int(tcpF.Fd()), int(file.Fd()), nil, int(fileInfo.Size())) return err } sendfile() copies data between one file descriptor and another. Because this copying is done within the kernel, sendfile() is more efficient than the combination of read(2) and write(2), which would require transferring data to and from user space. https://man7.org/linux/man-pages/man2/sendfile.2.html\nThe sendfile syscall is more efficient in transferring data than standard read and write methods. By bypassing the app buffer, the data moves directly from the read buffer to the socket buffer, reducing the number of data copies and context switches and improving performance. Furthermore, the process could requires less CPU intervention, allowing quicker data transfer and freeing up CPU for other tasks.\nThe sendfile syscall is known as a “zero-copy” method because it transfers data from one file descriptor to another without the need for an intermediate data copy in user-space memory.\nOf course this “zero-copy” is from a user-mode application point of view.\nThis scenario has two DMA copies + one CPU copy, and two context switches.\nThe sendfile syscall becomes even more efficient when the NIC supports Scatter/Gather. With SG, the syscall can directly transfer the data from the read buffer to the NIC, making the transfer a zero-copy operation that reduces the CPU load and enhances performance.\nGather refers to the ability of a Network Interface Card (NIC) to receive data from multiple memory locations and combine it into a single data buffer before transmitting it over the network. A NIC’s scatter/gather feature is used to increase the efficiency of data transfer by reducing the number of memory copies required to transmit the data. Instead of copying the data into a single buffer, the NIC can gather data from multiple buffers into a single buffer, reducing the CPU load and increasing the transfer’s performance. https://en.wikipedia.org/wiki/Gather/scatter_(vector_addressing)\nNic with gather supports\nThis scenario has just two DMA copies and two context switches.\nTherefore, reducing the number of buffer copies not only improves performance but also reduces memory usage, making the file transfer process more efficient and scalable.\nNote that the illustrations and scenarios provided are highly simplified and don’t fully represent the complexity of these processes. However, the aim was to present the information in a straightforward and easy-to-understand manner.\nWhy is “io.Copy” frequently recommended in Go? func sendFile(file *os.File, conn net.Conn) error { // Get file stat fileInfo, _ := file.Stat() // Send the file size sizeBuf := make([]byte, 8) binary.LittleEndian.PutUint64(sizeBuf, uint64(fileInfo.Size())) _, err := conn.Write(sizeBuf) if err != nil { return err } // Send the file contents _, err = io.Copy(conn, file) return err } The recommendation to use the io.Copy function in Go is due to its simplicity and efficiency. This function offers a streamlined way to copy data from an io.Reader to an io.Writer, managing buffering and chunking data to minimize memory usage and reduce syscalls. Additionally, io.Copy handles any potential errors during the copy process, making it a convenient and dependable option for data copying in Go.\nThe benefits of using io.Copy in Go go beyond its 32k buffer management and optimization src.\nfunc copyBuffer(dst Writer, src Reader, buf []byte) (written int64, err error) { ... if wt, ok := src.(WriterTo); ok { return wt.WriteTo(dst) } if rt, ok := dst.(ReaderFrom); ok { return rt.ReadFrom(src) } ... } When the destination satifies the ReadFrom interface, io.Copy utilizes this by calling ReadFrom to handle the copy process. For example, when dst is a TCPConn, io.Copy will call the underlying function to complete the copy src.\nfunc (c *TCPConn) readFrom(r io.Reader) (int64, error) { if n, err, handled := splice(c.fd, r); handled { return n, err } if n, err, handled := sendFile(c.fd, r); handled { return n, err } return genericReadFrom(c, r) } As you can see, when sending a file over a TCP connection, io.copy utilizes the sendfile syscall for efficient data transfer.\nBy running the program and using the strace tool to log all system calls, you can observe the use of the sendfile syscall in action:\n... [pid 67436] accept4(3, ... [pid 67440] epoll_pwait(5, [pid 67436] sendfile(4, 9, NULL, 4194304) = 143352 ... As observed in the implementation of ReadFrom, io.Copy not only attempts to use sendfile, but also the splice syscall, another useful system call for efficiently transferring data through pipes.\nIn addition, when the source satifies the WriteTo method, io.Copy will utilize it for the copy, avoiding any allocations and reducing the need for extra copying. This is why experts recommend using io.Copy whenever possible for copying or transferring data.\nPossible tips for Linux. I also try to improve performance on Linux systems for generic scenarios by increasing the MTU (Maximum Transmission Unit) size of the network interfaces and changing the TCP buffer size.\nThe Linux kernel parameters tcp_wmem and tcp_rmem control the transmit and receive buffer size for TCP connections, respectively. These parameters can be used to optimize the performance of TCP sockets.\ntcp_wmem determines the write buffer size for each socket, storing outgoing data before it is sent to the network. Larger buffers increase the amount of data sent at once, improving network efficiency.\ntcp_rmem sets the read buffer size for each socket, holding incoming data before the application processes it. This helps prevent network congestion and enhances efficiency.\nIncreasing both values will demand more memory usage.\nRead more.\n# See current tcp buffer values $ sysctl net.ipv4.tcp_wmem net.ipv4.tcp_wmem = 4096 16384 4194304 # Change the values $ sysctl -w net.ipv4.tcp_wmem=\"X X X\" # Change MTU $ ifconfig mtu up For me, these optimizations failed to deliver a substantial improvement due to certain constraints, such as the limitations of some devices, local network, etc.\nIn conclusion. The article discussed ways to send large files over TCP in Linux using Go, considering the constraints of small devices and the importance of efficient and reliable file transmission. The naive approach of copying data multiple times was deemed inefficient and increased memory usage, causing strain on the system’s resources. An alternative approach was presented, using the specialized syscall ‘sendfile’ and, more importantly, io.Copy which use sendfile under the hood for this scenario to minimize the number of buffer copies and context switches and reduce overhead to achieve a more efficient file transfer.\nThank you for taking the time to read this article. I hope it provided some helpful information. I constantly work to improve my understanding and knowledge, so I appreciate your feedback or corrections. Thank you again for your time and consideration.\nRepo\n","wordCount":"1841","inLanguage":"en","image":"https://www.kungfudev.com/img/naive-approach.png","datePublished":"2023-01-30T00:00:00Z","dateModified":"2023-01-30T00:00:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.kungfudev.com/posts/optimizing-large-file-transfer-linux-go/"},"publisher":{"@type":"Organization","name":"KungFu Developer","logo":{"@type":"ImageObject","url":"https://www.kungfudev.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.kungfudev.com accesskey=h title="KungFu Developer (Alt + H)">KungFu Developer</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://www.kungfudev.com/es/ title=Español aria-label=Español>Es</a></li></ul></div></div><ul id=menu><li><a href=https://www.kungfudev.com/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://www.kungfudev.com/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://www.kungfudev.com/archives/ title=Archives><span>Archives</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://www.kungfudev.com>Home</a>&nbsp;»&nbsp;<a href=https://www.kungfudev.com/posts/>Posts</a></div><h1 class=post-title>Optimizing Large File Transfers in Linux with Go - An Exploration of TCP and Syscall</h1><div class=post-meta><span title='2023-01-30 00:00:00 +0000 UTC'>January 30, 2023</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Me</div></header><figure class=entry-cover><img loading=lazy src=https://www.kungfudev.com/img/naive-approach.png alt></figure><div class=post-content><p>As I experiment with Raspberry Pi and other devices in my network, I have created a small network application to aid in device discovery using multicast, data collection, and other functions.</p><p>One key feature of this application is the ability to download various data and metrics from some plugins weekly. With file sizes ranging from 200 MB to 250 MB after applying some compression, it&rsquo;s essential to carefully consider some approaches for sending these files over TCP using Go.</p><p>In this article, we&rsquo;ll explore some approaches and tips for sending large files over TCP in linux using Go, taking into account the constraints of small devices and the importance of efficient and reliable file transmission.</p><h2 id=naive-approach>Naive approach<a hidden class=anchor aria-hidden=true href=#naive-approach>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>sendFile</span><span class=p>(</span><span class=nx>file</span> <span class=o>*</span><span class=nx>os</span><span class=p>.</span><span class=nx>File</span><span class=p>,</span> <span class=nx>conn</span> <span class=nx>net</span><span class=p>.</span><span class=nx>Conn</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// Get file stat
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>fileInfo</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>file</span><span class=p>.</span><span class=nf>Stat</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Send the file size
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>sizeBuf</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=mi>8</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>binary</span><span class=p>.</span><span class=nx>LittleEndian</span><span class=p>.</span><span class=nf>PutUint64</span><span class=p>(</span><span class=nx>sizeBuf</span><span class=p>,</span> <span class=nb>uint64</span><span class=p>(</span><span class=nx>fileInfo</span><span class=p>.</span><span class=nf>Size</span><span class=p>()))</span>
</span></span><span class=line><span class=cl>	<span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>conn</span><span class=p>.</span><span class=nf>Write</span><span class=p>(</span><span class=nx>sizeBuf</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Send the file contents by chunks
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>buf</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=mi>1024</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>n</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>file</span><span class=p>.</span><span class=nf>Read</span><span class=p>(</span><span class=nx>buf</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>err</span> <span class=o>==</span> <span class=nx>io</span><span class=p>.</span><span class=nx>EOF</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>break</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=p>=</span> <span class=nx>conn</span><span class=p>.</span><span class=nf>Write</span><span class=p>(</span><span class=nx>buf</span><span class=p>[:</span><span class=nx>n</span><span class=p>])</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;error writing to the conn:&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=k>break</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Although this code appears straightforward, it has a significant drawback regarding efficiency. The code moves data in a loop from the kernel buffer for the source to a buffer in user space and then immediately copies it from that buffer to the kernel buffer for the destination. This double copying of data results in a loss of performance as the buffer serves only as a temporary holding place.</p><p>While increasing the <code>buf</code> size to minimize the number of system calls might seem like a viable solution, it actually results in an increase in memory usage, making it an inefficient approach for tiny devices.</p><p>Moreover, the double copying of data also increases memory usage, as both the source and destination buffers must be allocated and maintained in memory. This can strain the system&rsquo;s resources, particularly when transferring large files and the devices are small.</p><p><img loading=lazy src=/img/naive-approach.png alt="Container commmunications"></p><p>The below diagram provides a simplified illustration of data flow when sending files over TCP. Using the previous approach, it&rsquo;s important to note that the data is copied four times before the process is complete:</p><ol><li>From the <code>disk</code> to the <code>read buffer</code> in the kernel space.</li><li>From the <code>read buffer</code> in the kernel space to the <code>app buffer</code> in the user space.</li><li>From the <code>app buffer</code> in the user space to the <code>socket buffer</code> in the kernel space.</li><li>Finally, from the <code>socket buffer</code> in the kernel space to the Network Interface Controller (NIC).</li></ol><p>This highlights the inefficiency of copying data multiple times, that&rsquo;s without mention the multiple context switches between user mode and kernel mode.</p><p>The data is copied from the disk to the read buffer in kernel space when a <code>read()</code> call is issued, and the copy is performed by direct memory access (DMA). This results in a context switch from user mode to kernel mode. The data is then copied from the read buffer to the app buffer by the CPU, which requires another context switch from kernel to user mode.</p><p>When a <code>write/send()</code> call is made, another context switch from user mode to kernel mode occurs, and the data is copied from the app buffer to a socket buffer in kernel space by the CPU. Then, a fourth context switch occurs as the <code>write/send()</code> call returns. The DMA engine then passes the data to the protocol engine asynchronously.</p><blockquote><p>What is DMA?</p><p>DMA stands for Direct Memory Access. It&rsquo;s a technology that allows peripheral devices to access computer memory directly, without needing the CPU, to speed up data transfer. In this way, the CPU is freed from performing the data transfer itself, allowing it to perform other tasks and making the system more efficient.
<a href=https://en.wikipedia.org/wiki/Direct_memory_access>https://en.wikipedia.org/wiki/Direct_memory_access</a></p></blockquote><p>To optimize the file transfer process, we have to minimize the number of buffer copies and context switches and reduce the overhead of moving data from one place to another.</p><h2 id=using-a-specialized-syscall-sendfile>Using a specialized syscall &lsquo;sendfile&rsquo;<a hidden class=anchor aria-hidden=true href=#using-a-specialized-syscall-sendfile>#</a></h2><p>Golang provides access to low-level operating system functionality through the <code>syscall</code> package, which contains an interface to various system primitives.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>sendFile</span><span class=p>(</span><span class=nx>file</span> <span class=o>*</span><span class=nx>os</span><span class=p>.</span><span class=nx>File</span><span class=p>,</span> <span class=nx>conn</span> <span class=nx>net</span><span class=p>.</span><span class=nx>Conn</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// Get file stat
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>fileInfo</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>file</span><span class=p>.</span><span class=nf>Stat</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Send the file size
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>sizeBuf</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=mi>8</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>binary</span><span class=p>.</span><span class=nx>LittleEndian</span><span class=p>.</span><span class=nf>PutUint64</span><span class=p>(</span><span class=nx>sizeBuf</span><span class=p>,</span> <span class=nb>uint64</span><span class=p>(</span><span class=nx>fileInfo</span><span class=p>.</span><span class=nf>Size</span><span class=p>()))</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>conn</span><span class=p>.</span><span class=nf>Write</span><span class=p>(</span><span class=nx>sizeBuf</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>tcpConn</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>conn</span><span class=p>.(</span><span class=o>*</span><span class=nx>net</span><span class=p>.</span><span class=nx>TCPConn</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>!</span><span class=nx>ok</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=s>&#34;TCPConn error&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>tcpF</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>tcpConn</span><span class=p>.</span><span class=nf>File</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Send the file contents
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=p>=</span> <span class=nx>syscall</span><span class=p>.</span><span class=nf>Sendfile</span><span class=p>(</span><span class=nb>int</span><span class=p>(</span><span class=nx>tcpF</span><span class=p>.</span><span class=nf>Fd</span><span class=p>()),</span> <span class=nb>int</span><span class=p>(</span><span class=nx>file</span><span class=p>.</span><span class=nf>Fd</span><span class=p>()),</span> <span class=kc>nil</span><span class=p>,</span> <span class=nb>int</span><span class=p>(</span><span class=nx>fileInfo</span><span class=p>.</span><span class=nf>Size</span><span class=p>()))</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><blockquote><p>sendfile() copies data between one file descriptor and another. Because this copying is done within the kernel, sendfile() is more efficient than the combination of read(2) and write(2), which would require transferring data to and from user space.
<a href=https://man7.org/linux/man-pages/man2/sendfile.2.html>https://man7.org/linux/man-pages/man2/sendfile.2.html</a></p></blockquote><p>The <code>sendfile</code> syscall is more efficient in transferring data than standard read and write methods. By bypassing the app buffer, the data moves directly from the read buffer to the socket buffer, reducing the number of data copies and context switches and improving performance. Furthermore, the process could requires less CPU intervention, allowing quicker data transfer and freeing up CPU for other tasks.</p><p>The <code>sendfile</code> syscall is known as a &ldquo;zero-copy&rdquo; method because it transfers data from one file descriptor to another without the need for an intermediate data copy in user-space memory.</p><p>Of course this &ldquo;zero-copy&rdquo; is from a user-mode application point of view.</p><p><img loading=lazy src=/img/sendfile-not-sg-approach.png alt="Container commmunications"></p><p>This scenario has two DMA copies + one CPU copy, and two context switches.</p><p>The <code>sendfile</code> syscall becomes even more efficient when the NIC supports Scatter/Gather. With SG, the syscall can directly transfer the data from the read buffer to the NIC, making the transfer a zero-copy operation that reduces the CPU load and enhances performance.</p><blockquote><p>Gather refers to the ability of a Network Interface Card (NIC) to receive data from multiple memory locations and combine it into a single data buffer before transmitting it over the network. A NIC&rsquo;s scatter/gather feature is used to increase the efficiency of data transfer by reducing the number of memory copies required to transmit the data. Instead of copying the data into a single buffer, the NIC can gather data from multiple buffers into a single buffer, reducing the CPU load and increasing the transfer&rsquo;s performance.
<a href=https://en.wikipedia.org/wiki/Gather/scatter_(vector_addressing)>https://en.wikipedia.org/wiki/Gather/scatter_(vector_addressing)</a></p></blockquote><p><strong>Nic with gather supports</strong></p><p><img loading=lazy src=/img/sendfile-sg-approach.png alt="Container commmunications"></p><p>This scenario has just two DMA copies and two context switches.</p><p>Therefore, reducing the number of buffer copies not only improves performance but also reduces memory usage, making the file transfer process more efficient and scalable.</p><p>Note that the illustrations and scenarios provided are highly simplified and don&rsquo;t fully represent the complexity of these processes. However, the aim was to present the information in a straightforward and easy-to-understand manner.</p><h2 id=why-is-iocopy-frequently-recommended-in-go>Why is &ldquo;io.Copy&rdquo; frequently recommended in Go?<a hidden class=anchor aria-hidden=true href=#why-is-iocopy-frequently-recommended-in-go>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>sendFile</span><span class=p>(</span><span class=nx>file</span> <span class=o>*</span><span class=nx>os</span><span class=p>.</span><span class=nx>File</span><span class=p>,</span> <span class=nx>conn</span> <span class=nx>net</span><span class=p>.</span><span class=nx>Conn</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// Get file stat
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>fileInfo</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>file</span><span class=p>.</span><span class=nf>Stat</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Send the file size
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>sizeBuf</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=mi>8</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>binary</span><span class=p>.</span><span class=nx>LittleEndian</span><span class=p>.</span><span class=nf>PutUint64</span><span class=p>(</span><span class=nx>sizeBuf</span><span class=p>,</span> <span class=nb>uint64</span><span class=p>(</span><span class=nx>fileInfo</span><span class=p>.</span><span class=nf>Size</span><span class=p>()))</span>
</span></span><span class=line><span class=cl>	<span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>conn</span><span class=p>.</span><span class=nf>Write</span><span class=p>(</span><span class=nx>sizeBuf</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Send the file contents
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=p>=</span> <span class=nx>io</span><span class=p>.</span><span class=nf>Copy</span><span class=p>(</span><span class=nx>conn</span><span class=p>,</span> <span class=nx>file</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The recommendation to use the <code>io.Copy</code> function in Go is due to its simplicity and efficiency. This function offers a streamlined way to copy data from an io.Reader to an io.Writer, managing buffering and chunking data to minimize memory usage and reduce syscalls. Additionally, io.Copy handles any potential errors during the copy process, making it a convenient and dependable option for data copying in Go.</p><p>The benefits of using io.Copy in Go go beyond its 32k buffer management and optimization <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.19.5:src/io/io.go;l=424">src</a>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>copyBuffer</span><span class=p>(</span><span class=nx>dst</span> <span class=nx>Writer</span><span class=p>,</span> <span class=nx>src</span> <span class=nx>Reader</span><span class=p>,</span> <span class=nx>buf</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=p>(</span><span class=nx>written</span> <span class=kt>int64</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=o>...</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>wt</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>src</span><span class=p>.(</span><span class=nx>WriterTo</span><span class=p>);</span> <span class=nx>ok</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>wt</span><span class=p>.</span><span class=nf>WriteTo</span><span class=p>(</span><span class=nx>dst</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>rt</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>dst</span><span class=p>.(</span><span class=nx>ReaderFrom</span><span class=p>);</span> <span class=nx>ok</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>rt</span><span class=p>.</span><span class=nf>ReadFrom</span><span class=p>(</span><span class=nx>src</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=o>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>When the destination satifies the <code>ReadFrom</code> interface, io.Copy utilizes this by calling <code>ReadFrom</code> to handle the copy process. For example, when <code>dst</code> is a <code>TCPConn</code>, <code>io.Copy</code> will call the underlying function to complete the copy <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.19.5:src/net/tcpsock_posix.go;drc=007d8f4db1f890f0d34018bb418bdc90ad4a8c35;l=47">src</a>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>TCPConn</span><span class=p>)</span> <span class=nf>readFrom</span><span class=p>(</span><span class=nx>r</span> <span class=nx>io</span><span class=p>.</span><span class=nx>Reader</span><span class=p>)</span> <span class=p>(</span><span class=kt>int64</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>n</span><span class=p>,</span> <span class=nx>err</span><span class=p>,</span> <span class=nx>handled</span> <span class=o>:=</span> <span class=nf>splice</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nx>fd</span><span class=p>,</span> <span class=nx>r</span><span class=p>);</span> <span class=nx>handled</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>n</span><span class=p>,</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>n</span><span class=p>,</span> <span class=nx>err</span><span class=p>,</span> <span class=nx>handled</span> <span class=o>:=</span> <span class=nf>sendFile</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nx>fd</span><span class=p>,</span> <span class=nx>r</span><span class=p>);</span> <span class=nx>handled</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>n</span><span class=p>,</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nf>genericReadFrom</span><span class=p>(</span><span class=nx>c</span><span class=p>,</span> <span class=nx>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>As you can see, when sending a file over a TCP connection, <code>io.copy</code> utilizes the <code>sendfile</code> syscall for efficient data transfer.</p><p>By running the program and using the <code>strace</code> tool to log all system calls, you can observe the use of the <code>sendfile</code> syscall in action:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-txt data-lang=txt><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>[pid 67436] accept4(3,  &lt;unfinished ...&gt;
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>[pid 67440] epoll_pwait(5,  &lt;unfinished ...&gt;
</span></span><span class=line><span class=cl>[pid 67436] sendfile(4, 9, NULL, 4194304) = 143352
</span></span><span class=line><span class=cl>...
</span></span></code></pre></div><p>As observed in the implementation of <code>ReadFrom</code>, <code>io.Copy</code> not only attempts to use <code>sendfile</code>, but also the <code>splice</code> syscall, another useful system call for efficiently transferring data through pipes.</p><p>In addition, when the source satifies the <code>WriteTo</code> method, <code>io.Copy</code> will utilize it for the copy, avoiding any allocations and reducing the need for extra copying. This is why experts recommend using <code>io.Copy</code> whenever possible for copying or transferring data.</p><h3 id=possible-tips-for-linux>Possible tips for Linux.<a hidden class=anchor aria-hidden=true href=#possible-tips-for-linux>#</a></h3><p>I also try to improve performance on Linux systems for generic scenarios by increasing the MTU (Maximum Transmission Unit) size of the network interfaces and changing the TCP buffer size.</p><p>The Linux kernel parameters <code>tcp_wmem</code> and <code>tcp_rmem</code> control the transmit and receive buffer size for TCP connections, respectively. These parameters can be used to optimize the performance of TCP sockets.</p><p><code>tcp_wmem</code> determines the write buffer size for each socket, storing outgoing data before it is sent to the network. Larger buffers increase the amount of data sent at once, improving network efficiency.</p><p><code>tcp_rmem</code> sets the read buffer size for each socket, holding incoming data before the application processes it. This helps prevent network congestion and enhances efficiency.</p><p>Increasing both values will demand more memory usage.</p><p><a href="https://www.ibm.com/docs/en/linux-on-systems?topic=tuning-tcpip-ipv4-settings">Read more.</a></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># See current tcp buffer values</span>
</span></span><span class=line><span class=cl>$ sysctl net.ipv4.tcp_wmem
</span></span><span class=line><span class=cl>net.ipv4.tcp_wmem <span class=o>=</span> <span class=m>4096</span> <span class=m>16384</span> <span class=m>4194304</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Change the values</span>
</span></span><span class=line><span class=cl>$ sysctl -w net.ipv4.tcp_wmem<span class=o>=</span><span class=s2>&#34;X X X&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Change MTU</span>
</span></span><span class=line><span class=cl>$ ifconfig &lt;Interface_name&gt; mtu &lt;mtu_size&gt; up
</span></span></code></pre></div><p>For me, these optimizations failed to deliver a substantial improvement due to certain constraints, such as the limitations of some devices, local network, etc.</p><h3 id=in-conclusion>In conclusion.<a hidden class=anchor aria-hidden=true href=#in-conclusion>#</a></h3><p>The article discussed ways to send large files over TCP in Linux using Go, considering the constraints of small devices and the importance of efficient and reliable file transmission. The naive approach of copying data multiple times was deemed inefficient and increased memory usage, causing strain on the system&rsquo;s resources. An alternative approach was presented, using the specialized syscall &lsquo;sendfile&rsquo; and, more importantly, <code>io.Copy</code> which use <code>sendfile</code> under the hood for this scenario to minimize the number of buffer copies and context switches and reduce overhead to achieve a more efficient file transfer.</p><p>Thank you for taking the time to read this article. I hope it provided some helpful information. I constantly work to improve my understanding and knowledge, so I appreciate your feedback or corrections. Thank you again for your time and consideration.</p><p><a href=https://github.com/douglasmakey/send-file-over-tcp-demo>Repo</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://www.kungfudev.com/tags/go/>go</a></li><li><a href=https://www.kungfudev.com/tags/linux/>linux</a></li><li><a href=https://www.kungfudev.com/tags/socket/>socket</a></li><li><a href=https://www.kungfudev.com/tags/network/>network</a></li><li><a href=https://www.kungfudev.com/tags/unix/>unix</a></li></ul><nav class=paginav><a class=next href=https://www.kungfudev.com/posts/cel-for-admission-controller/><span class=title>Next »</span><br><span>CEL for admission controller with ValidatingAdmissionPolicy in K8s 1.26</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Optimizing Large File Transfers in Linux with Go - An Exploration of TCP and Syscall on twitter" href="https://twitter.com/intent/tweet/?text=Optimizing%20Large%20File%20Transfers%20in%20Linux%20with%20Go%20-%20An%20Exploration%20of%20TCP%20and%20Syscall&url=https%3a%2f%2fwww.kungfudev.com%2fposts%2foptimizing-large-file-transfer-linux-go%2f&hashtags=go%2clinux%2csocket%2cnetwork%2cunix"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Optimizing Large File Transfers in Linux with Go - An Exploration of TCP and Syscall on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fwww.kungfudev.com%2fposts%2foptimizing-large-file-transfer-linux-go%2f&title=Optimizing%20Large%20File%20Transfers%20in%20Linux%20with%20Go%20-%20An%20Exploration%20of%20TCP%20and%20Syscall&summary=Optimizing%20Large%20File%20Transfers%20in%20Linux%20with%20Go%20-%20An%20Exploration%20of%20TCP%20and%20Syscall&source=https%3a%2f%2fwww.kungfudev.com%2fposts%2foptimizing-large-file-transfer-linux-go%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Optimizing Large File Transfers in Linux with Go - An Exploration of TCP and Syscall on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fwww.kungfudev.com%2fposts%2foptimizing-large-file-transfer-linux-go%2f&title=Optimizing%20Large%20File%20Transfers%20in%20Linux%20with%20Go%20-%20An%20Exploration%20of%20TCP%20and%20Syscall"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Optimizing Large File Transfers in Linux with Go - An Exploration of TCP and Syscall on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwww.kungfudev.com%2fposts%2foptimizing-large-file-transfer-linux-go%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Optimizing Large File Transfers in Linux with Go - An Exploration of TCP and Syscall on whatsapp" href="https://api.whatsapp.com/send?text=Optimizing%20Large%20File%20Transfers%20in%20Linux%20with%20Go%20-%20An%20Exploration%20of%20TCP%20and%20Syscall%20-%20https%3a%2f%2fwww.kungfudev.com%2fposts%2foptimizing-large-file-transfer-linux-go%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Optimizing Large File Transfers in Linux with Go - An Exploration of TCP and Syscall on telegram" href="https://telegram.me/share/url?text=Optimizing%20Large%20File%20Transfers%20in%20Linux%20with%20Go%20-%20An%20Exploration%20of%20TCP%20and%20Syscall&url=https%3a%2f%2fwww.kungfudev.com%2fposts%2foptimizing-large-file-transfer-linux-go%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://www.kungfudev.com>KungFu Developer</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>
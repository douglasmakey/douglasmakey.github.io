<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Socket sharding in Linux example with Go | KungFu Developer</title><meta name=keywords content="linux,go,sockets"><meta name=description content="I bet there have been many times that you were working on the terminal with multiple tabs and you launched an HTTP server, and then you forgot that the server was already being executed, and then you tried to relaunch it from another tab getting the known error:
go run main.go listen tcp :8080: bind: address already in use This is because we cannot open a socket with the same source address and port by default in Linux and the vast majority of operating systems."><meta name=author content="Me"><link rel=canonical href=https://www.kungfudev.com/posts/socket-sharding-go/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://www.kungfudev.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.kungfudev.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.kungfudev.com/favicon-32x32.png><link rel=apple-touch-icon href=https://www.kungfudev.com/apple-touch-icon.png><link rel=mask-icon href=https://www.kungfudev.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://www.kungfudev.com/posts/socket-sharding-go/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Socket sharding in Linux example with Go"><meta property="og:description" content="I bet there have been many times that you were working on the terminal with multiple tabs and you launched an HTTP server, and then you forgot that the server was already being executed, and then you tried to relaunch it from another tab getting the known error:
go run main.go listen tcp :8080: bind: address already in use This is because we cannot open a socket with the same source address and port by default in Linux and the vast majority of operating systems."><meta property="og:type" content="article"><meta property="og:url" content="https://www.kungfudev.com/posts/socket-sharding-go/"><meta property="og:image" content="https://www.kungfudev.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-08-21T00:00:00+00:00"><meta property="article:modified_time" content="2021-08-21T00:00:00+00:00"><meta property="og:site_name" content="I'm a Kung Fu Deveveloper"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.kungfudev.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Socket sharding in Linux example with Go"><meta name=twitter:description content="I bet there have been many times that you were working on the terminal with multiple tabs and you launched an HTTP server, and then you forgot that the server was already being executed, and then you tried to relaunch it from another tab getting the known error:
go run main.go listen tcp :8080: bind: address already in use This is because we cannot open a socket with the same source address and port by default in Linux and the vast majority of operating systems."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://www.kungfudev.com/posts/"},{"@type":"ListItem","position":3,"name":"Socket sharding in Linux example with Go","item":"https://www.kungfudev.com/posts/socket-sharding-go/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Socket sharding in Linux example with Go","name":"Socket sharding in Linux example with Go","description":"I bet there have been many times that you were working on the terminal with multiple tabs and you launched an HTTP server, and then you forgot that the server was already being executed, and then you tried to relaunch it from another tab getting the known error:\ngo run main.go listen tcp :8080: bind: address already in use This is because we cannot open a socket with the same source address and port by default in Linux and the vast majority of operating systems.","keywords":["linux","go","sockets"],"articleBody":"I bet there have been many times that you were working on the terminal with multiple tabs and you launched an HTTP server, and then you forgot that the server was already being executed, and then you tried to relaunch it from another tab getting the known error:\ngo run main.go listen tcp :8080: bind: address already in use This is because we cannot open a socket with the same source address and port by default in Linux and the vast majority of operating systems.\nSocket options When we create a new TCP socket on Linux, we can set options that affect the behaviour of the socket. For example, one of these options is SO_REUSEPORT, which allows multiple sockets to bind to the same IP address and port. With this feature, the Linux kernel distributes incoming requests across all the sockets that share the same address and port combination, getting a load balancing inside the Kernel.\nSO_REUSEPORT\nFor TCP sockets, this option allows accept(2) load distribution in a multi-threaded server to be improved by using a distinct listener socket for each thread. This provides improved load distribution as compared to traditional techniques such using a single accept(2)ing thread that distributes connections, or having multiple threads that compete to accept(2) from the same socket.\nFor UDP sockets, the use of this option can provide better distribution of incoming datagrams to multiple processes (or threads) as compared to the traditional technique of having multiple processes compete to receive datagrams on the same socket.\nhttps://man7.org/linux/man-pages/man7/socket.7.html\nAs we can notice, we not only get the super power to create more than one socket with the same IP: Port combination, but we also obtain a kind of load balancer in the kernel mode.\nGo sockets When we invoke the net.Listen() function in Go, this function use the ListenConfig struct to create the Listener.\nfunc Listen(network, address string) (Listener, error) { var lc ListenConfig return lc.Listen(context.Background(), network, address) } If we inspect ListenConfig we can find the method Control and the documentation says: If Control is not nil, it is called after creating the network connection but before binding it to the operating system.\n// ListenConfig contains options for listening to an address. type ListenConfig struct { // If Control is not nil, it is called after creating the network // connection but before binding it to the operating system. // ... Control func(network, address string, c syscall.RawConn) error ... } The function Control receives the syscall.RawConn which is a raw network connection that has a method also called control (Control(f func(fd uintptr))) where it will invoke the function f on the underlying connection’s file descriptor.\nHaving the file descriptor, now we can use the golang.org/x/sys/unix package to set the socket options.\n// fd -\u003e the underlying connection's file descriptor. // unix.SOL_SOCKET -\u003e to set options at the socket level, we have to specify the level argument as SOL_SOCKET. unix.SetsockoptInt(int(fd), unix.SOL_SOCKET, unix.SO_REUSEPORT, 1) So, we could create a instance of ListenConfig with a control function to set the SO_REUSEPORT socket options to our sockets.\nvar lc = net.ListenConfig{ Control: func(network, address string, c syscall.RawConn) error { var opErr error if err := c.Control(func(fd uintptr) { opErr = unix.SetsockoptInt(int(fd), unix.SOL_SOCKET, unix.SO_REUSEPORT, 1) }); err != nil { return err } return opErr }, } Security One question we might have at this point is, what about security? I mean, if we can open a socket with the same IP: Port of a specific app, for example, Nginx, we could hijack part of the requests that the kernel will send to us through the socket. Right?\nWell, to prevent this “port hijacking,” Linux has special protections or mechanisms to prevent these problems, such as:\nBoth sockets must have been created with the SO_REUSEPORT socket option. If there is a socket running without SO_REUSEPORT and we try to create another socket even with the SO_REUSEPORT socket option, it will fail with the error already in use. All sockets that want to listen to the same IP and port combination must have the same effective userID. For example, if you want to hijack the Nginx port and it is running under the ownership of the user Pepito, a new process can listen to the same port only if it is also owned by the user Pepito. So one user cannot “steal” ports of other users. The following are super simple use cases for SO_REUSEPORT, of course omitting all the complexity required to achieve them:\nWe could run multiple instances of our app to take advantage of our resources without the necessity of running a proxy in front of them (to have an ultra simple LB). Having multiple threads/processes/instances will have better performance than having a single one. Can give us the possibility of zero downtime updates. Since we can launch a new instance to receive requests and, after that, kill the old one with a graceful shutdown. Simple demo In this repository, you will find the complete code example in Go to test this, but as it is a fairly simple code and something short, you will also have it below:\npackage main import ( \"context\" \"fmt\" \"net\" \"net/http\" \"os\" \"syscall\" \"golang.org/x/sys/unix\" ) var lc = net.ListenConfig{ Control: func(network, address string, c syscall.RawConn) error { var opErr error if err := c.Control(func(fd uintptr) { opErr = unix.SetsockoptInt(int(fd), unix.SOL_SOCKET, unix.SO_REUSEPORT, 1) }); err != nil { return err } return opErr }, } func main() { pid := os.Getpid() l, err := lc.Listen(context.Background(), \"tcp\", \"127.0.0.1:8080\") if err != nil { panic(err) } server := \u0026http.Server{} http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) { w.WriteHeader(http.StatusOK) fmt.Fprintf(w, \"Hello from PID %d \\n\", pid) }) fmt.Printf(\"HTTP Server with PID: %d is running \\n\", pid) panic(server.Serve(l)) } Using the above code, we can open a terminal with 3 tabs. In the first one, we will run the program:\n$ go run main.go HTTP Server with PID: 8183 is running In the second one, we will have another instance of our program.\n$ go run main.go HTTP Server with PID: 8298 is running Then, in the last one, we will run a simple loop to hit our servers, and you should have a similar result:\n$ for i in {1..20}; do curl localhost:8080; done Hello from PID 8183 Hello from PID 8183 Hello from PID 8183 Hello from PID 8183 Hello from PID 8183 Hello from PID 8183 Hello from PID 8183 Hello from PID 8183 Hello from PID 8183 Hello from PID 8298 Hello from PID 8298 Hello from PID 8183 Hello from PID 8183 Hello from PID 8183 Hello from PID 8298 Hello from PID 8298 Hello from PID 8298 Hello from PID 8183 Hello from PID 8183 Hello from PID 8298 I hope you enjoyed this little article, for me this was very interesting and that is why I decided to share it with you \u003c3\nRelated link:\nhttps://lwn.net/Articles/542629/ https://man7.org/linux/man-pages/man7/socket.7.html https://www.nginx.com/blog/socket-sharding-nginx-release-1-9-1/ ","wordCount":"1146","inLanguage":"en","datePublished":"2021-08-21T00:00:00Z","dateModified":"2021-08-21T00:00:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.kungfudev.com/posts/socket-sharding-go/"},"publisher":{"@type":"Organization","name":"KungFu Developer","logo":{"@type":"ImageObject","url":"https://www.kungfudev.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.kungfudev.com accesskey=h title="KungFu Developer (Alt + H)">KungFu Developer</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://www.kungfudev.com/es/ title=Español aria-label=Español>Es</a></li></ul></div></div><ul id=menu><li><a href=https://www.kungfudev.com/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://www.kungfudev.com/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://www.kungfudev.com/archives/ title=Archives><span>Archives</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://www.kungfudev.com>Home</a>&nbsp;»&nbsp;<a href=https://www.kungfudev.com/posts/>Posts</a></div><h1 class=post-title>Socket sharding in Linux example with Go</h1><div class=post-meta><span title='2021-08-21 00:00:00 +0000 UTC'>August 21, 2021</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</div></header><div class=post-content><p>I bet there have been many times that you were working on the terminal with multiple tabs and you launched an HTTP server, and then you forgot that the server was already being executed, and then you tried to relaunch it from another tab getting the known error:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>go run main.go
</span></span><span class=line><span class=cl>listen tcp :8080: bind: address already in use
</span></span></code></pre></div><p>This is because we cannot open a socket with the same source address and port by default in Linux and the vast majority of operating systems.</p><h3 id=socket-options>Socket options<a hidden class=anchor aria-hidden=true href=#socket-options>#</a></h3><p>When we create a new TCP socket on Linux, we can set options that affect the behaviour of the socket. For example, one of these options is <code>SO_REUSEPORT</code>, which allows multiple sockets to bind to the same IP address and port. With this feature, the Linux kernel distributes incoming requests across all the sockets that share the same address and port combination, getting a load balancing inside the Kernel.</p><blockquote><p>SO_REUSEPORT</p><p>For TCP sockets, this option allows accept(2) load distribution in a multi-threaded server to be improved by using a distinct listener socket for each thread. This provides improved load distribution as compared to traditional techniques such using a single accept(2)ing thread that distributes connections, or having multiple threads that compete to accept(2) from the same socket.</p><p>For UDP sockets, the use of this option can provide better distribution of incoming datagrams to multiple processes (or threads) as compared to the traditional technique of having multiple processes compete to receive datagrams on the same socket.</p><p><a href=https://man7.org/linux/man-pages/man7/socket.7.html>https://man7.org/linux/man-pages/man7/socket.7.html</a></p></blockquote><p><img loading=lazy src=https://user-images.githubusercontent.com/8400576/127754771-6a789f00-7022-4602-a628-a3d124b43421.png alt></p><p>As we can notice, we not only get the super power to create more than one socket with the same IP: Port combination, but we also obtain a kind of load balancer in the kernel mode.</p><h3 id=go-sockets>Go sockets<a hidden class=anchor aria-hidden=true href=#go-sockets>#</a></h3><p>When we invoke the <code>net.Listen()</code> function in Go, this function use the <code>ListenConfig</code> struct to create the Listener.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Listen</span><span class=p>(</span><span class=nx>network</span><span class=p>,</span> <span class=nx>address</span> <span class=kt>string</span><span class=p>)</span> <span class=p>(</span><span class=nx>Listener</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>lc</span> <span class=nx>ListenConfig</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>lc</span><span class=p>.</span><span class=nf>Listen</span><span class=p>(</span><span class=nx>context</span><span class=p>.</span><span class=nf>Background</span><span class=p>(),</span> <span class=nx>network</span><span class=p>,</span> <span class=nx>address</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>If we inspect <code>ListenConfig</code> we can find the method <code>Control</code> and the documentation says: If Control is not nil, it is called after creating the network connection but before binding it to the operating system.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// ListenConfig contains options for listening to an address.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>ListenConfig</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// If Control is not nil, it is called after creating the network
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// connection but before binding it to the operating system.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>Control</span> <span class=kd>func</span><span class=p>(</span><span class=nx>network</span><span class=p>,</span> <span class=nx>address</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>c</span> <span class=nx>syscall</span><span class=p>.</span><span class=nx>RawConn</span><span class=p>)</span> <span class=kt>error</span>
</span></span><span class=line><span class=cl>	<span class=o>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The function <code>Control</code> receives the <code>syscall.RawConn</code> which is a raw network connection that has a method also called control (<code>Control(f func(fd uintptr))</code>) where it will invoke the function <code>f</code> on the underlying connection&rsquo;s file descriptor.</p><p>Having the file descriptor, now we can use the <code>golang.org/x/sys/unix</code> package to set the socket options.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// fd -&gt; the underlying connection&#39;s file descriptor.
</span></span></span><span class=line><span class=cl><span class=c1>// unix.SOL_SOCKET  -&gt; to set options at the socket level, we have to specify the level argument as SOL_SOCKET.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>unix</span><span class=p>.</span><span class=nf>SetsockoptInt</span><span class=p>(</span><span class=nb>int</span><span class=p>(</span><span class=nx>fd</span><span class=p>),</span> <span class=nx>unix</span><span class=p>.</span><span class=nx>SOL_SOCKET</span><span class=p>,</span> <span class=nx>unix</span><span class=p>.</span><span class=nx>SO_REUSEPORT</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span></code></pre></div><p>So, we could create a instance of <code>ListenConfig</code> with a control function to set the <code>SO_REUSEPORT</code> socket options to our sockets.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>lc</span> <span class=p>=</span> <span class=nx>net</span><span class=p>.</span><span class=nx>ListenConfig</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>Control</span><span class=p>:</span> <span class=kd>func</span><span class=p>(</span><span class=nx>network</span><span class=p>,</span> <span class=nx>address</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>c</span> <span class=nx>syscall</span><span class=p>.</span><span class=nx>RawConn</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=kd>var</span> <span class=nx>opErr</span> <span class=kt>error</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nf>Control</span><span class=p>(</span><span class=kd>func</span><span class=p>(</span><span class=nx>fd</span> <span class=kt>uintptr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>opErr</span> <span class=p>=</span> <span class=nx>unix</span><span class=p>.</span><span class=nf>SetsockoptInt</span><span class=p>(</span><span class=nb>int</span><span class=p>(</span><span class=nx>fd</span><span class=p>),</span> <span class=nx>unix</span><span class=p>.</span><span class=nx>SOL_SOCKET</span><span class=p>,</span> <span class=nx>unix</span><span class=p>.</span><span class=nx>SO_REUSEPORT</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>});</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>opErr</span>
</span></span><span class=line><span class=cl>	<span class=p>},</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=security>Security<a hidden class=anchor aria-hidden=true href=#security>#</a></h3><p>One question we might have at this point is, what about security? I mean, if we can open a socket with the same IP: Port of a specific app, for example, Nginx, we could hijack part of the requests that the kernel will send to us through the socket. Right?</p><p>Well, to prevent this &ldquo;port hijacking,&rdquo; Linux has special protections or mechanisms to prevent these problems, such as:</p><ul><li>Both sockets must have been created with the SO_REUSEPORT socket option. If there is a socket running without SO_REUSEPORT and we try to create another socket even with the SO_REUSEPORT socket option, it will fail with the error <code>already in use</code>.</li><li>All sockets that want to listen to the same IP and port combination must have the same effective userID. For example, if you want to hijack the Nginx port and it is running under the ownership of the user Pepito, a new process can listen to the same port only if it is also owned by the user Pepito. So one user cannot &ldquo;steal&rdquo; ports of other users.</li></ul><p>The following are super simple use cases for <code>SO_REUSEPORT</code>, of course omitting all the complexity required to achieve them:</p><ul><li>We could run multiple instances of our app to take advantage of our resources without the necessity of running a proxy in front of them (to have an ultra simple LB). Having multiple threads/processes/instances will have better performance than having a single one.</li><li>Can give us the possibility of zero downtime updates. Since we can launch a new instance to receive requests and, after that, kill the old one with a graceful shutdown.</li></ul><h3 id=simple-demo>Simple demo<a hidden class=anchor aria-hidden=true href=#simple-demo>#</a></h3><p>In this <a href=https://github.com/douglasmakey/socket-sharding/blob/master/cmd/http-example/main.go>repository</a>, you will find the complete code example in Go to test this, but as it is a fairly simple code and something short, you will also have it below:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;context&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;net&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;net/http&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;os&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;syscall&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=s>&#34;golang.org/x/sys/unix&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>lc</span> <span class=p>=</span> <span class=nx>net</span><span class=p>.</span><span class=nx>ListenConfig</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>Control</span><span class=p>:</span> <span class=kd>func</span><span class=p>(</span><span class=nx>network</span><span class=p>,</span> <span class=nx>address</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>c</span> <span class=nx>syscall</span><span class=p>.</span><span class=nx>RawConn</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=kd>var</span> <span class=nx>opErr</span> <span class=kt>error</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nf>Control</span><span class=p>(</span><span class=kd>func</span><span class=p>(</span><span class=nx>fd</span> <span class=kt>uintptr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>opErr</span> <span class=p>=</span> <span class=nx>unix</span><span class=p>.</span><span class=nf>SetsockoptInt</span><span class=p>(</span><span class=nb>int</span><span class=p>(</span><span class=nx>fd</span><span class=p>),</span> <span class=nx>unix</span><span class=p>.</span><span class=nx>SOL_SOCKET</span><span class=p>,</span> <span class=nx>unix</span><span class=p>.</span><span class=nx>SO_REUSEPORT</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>});</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>opErr</span>
</span></span><span class=line><span class=cl>	<span class=p>},</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>pid</span> <span class=o>:=</span> <span class=nx>os</span><span class=p>.</span><span class=nf>Getpid</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>l</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>lc</span><span class=p>.</span><span class=nf>Listen</span><span class=p>(</span><span class=nx>context</span><span class=p>.</span><span class=nf>Background</span><span class=p>(),</span> <span class=s>&#34;tcp&#34;</span><span class=p>,</span> <span class=s>&#34;127.0.0.1:8080&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nb>panic</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>server</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>http</span><span class=p>.</span><span class=nx>Server</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>	<span class=nx>http</span><span class=p>.</span><span class=nf>HandleFunc</span><span class=p>(</span><span class=s>&#34;/&#34;</span><span class=p>,</span> <span class=kd>func</span><span class=p>(</span><span class=nx>w</span> <span class=nx>http</span><span class=p>.</span><span class=nx>ResponseWriter</span><span class=p>,</span> <span class=nx>r</span> <span class=o>*</span><span class=nx>http</span><span class=p>.</span><span class=nx>Request</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>w</span><span class=p>.</span><span class=nf>WriteHeader</span><span class=p>(</span><span class=nx>http</span><span class=p>.</span><span class=nx>StatusOK</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>fmt</span><span class=p>.</span><span class=nf>Fprintf</span><span class=p>(</span><span class=nx>w</span><span class=p>,</span> <span class=s>&#34;Hello from PID %d \n&#34;</span><span class=p>,</span> <span class=nx>pid</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>})</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;HTTP Server with PID: %d is running \n&#34;</span><span class=p>,</span> <span class=nx>pid</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nb>panic</span><span class=p>(</span><span class=nx>server</span><span class=p>.</span><span class=nf>Serve</span><span class=p>(</span><span class=nx>l</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Using the above code, we can open a terminal with 3 tabs. In the first one, we will run the program:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ go run main.go
</span></span><span class=line><span class=cl>HTTP Server with PID: <span class=m>8183</span> is running
</span></span></code></pre></div><p>In the second one, we will have another instance of our program.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ go run main.go
</span></span><span class=line><span class=cl>HTTP Server with PID: <span class=m>8298</span> is running
</span></span></code></pre></div><p>Then, in the last one, we will run a simple loop to hit our servers, and you should have a similar result:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ <span class=k>for</span> i in <span class=o>{</span>1..20<span class=o>}</span><span class=p>;</span> <span class=k>do</span> curl localhost:8080<span class=p>;</span> <span class=k>done</span>
</span></span><span class=line><span class=cl>Hello from PID <span class=m>8183</span>
</span></span><span class=line><span class=cl>Hello from PID <span class=m>8183</span>
</span></span><span class=line><span class=cl>Hello from PID <span class=m>8183</span>
</span></span><span class=line><span class=cl>Hello from PID <span class=m>8183</span>
</span></span><span class=line><span class=cl>Hello from PID <span class=m>8183</span>
</span></span><span class=line><span class=cl>Hello from PID <span class=m>8183</span>
</span></span><span class=line><span class=cl>Hello from PID <span class=m>8183</span>
</span></span><span class=line><span class=cl>Hello from PID <span class=m>8183</span>
</span></span><span class=line><span class=cl>Hello from PID <span class=m>8183</span>
</span></span><span class=line><span class=cl>Hello from PID <span class=m>8298</span>
</span></span><span class=line><span class=cl>Hello from PID <span class=m>8298</span>
</span></span><span class=line><span class=cl>Hello from PID <span class=m>8183</span>
</span></span><span class=line><span class=cl>Hello from PID <span class=m>8183</span>
</span></span><span class=line><span class=cl>Hello from PID <span class=m>8183</span>
</span></span><span class=line><span class=cl>Hello from PID <span class=m>8298</span>
</span></span><span class=line><span class=cl>Hello from PID <span class=m>8298</span>
</span></span><span class=line><span class=cl>Hello from PID <span class=m>8298</span>
</span></span><span class=line><span class=cl>Hello from PID <span class=m>8183</span>
</span></span><span class=line><span class=cl>Hello from PID <span class=m>8183</span>
</span></span><span class=line><span class=cl>Hello from PID <span class=m>8298</span>
</span></span></code></pre></div><p>I hope you enjoyed this little article, for me this was very interesting and that is why I decided to share it with you &lt;3</p><p>Related link:</p><ul><li><a href=https://lwn.net/Articles/542629/>https://lwn.net/Articles/542629/</a></li><li><a href=https://man7.org/linux/man-pages/man7/socket.7.html>https://man7.org/linux/man-pages/man7/socket.7.html</a></li><li><a href=https://www.nginx.com/blog/socket-sharding-nginx-release-1-9-1/>https://www.nginx.com/blog/socket-sharding-nginx-release-1-9-1/</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://www.kungfudev.com/tags/linux/>linux</a></li><li><a href=https://www.kungfudev.com/tags/go/>go</a></li><li><a href=https://www.kungfudev.com/tags/sockets/>sockets</a></li></ul><nav class=paginav><a class=prev href=https://www.kungfudev.com/posts/understanding-unix-domain-sockets-in-golang/><span class=title>« Prev</span><br><span>Understanding Unix Domain Sockets in Golang</span></a>
<a class=next href=https://www.kungfudev.com/posts/implementing-k8s-admission-controller/><span class=title>Next »</span><br><span>Implementing a simple K8s admission controller in Go</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Socket sharding in Linux example with Go on twitter" href="https://twitter.com/intent/tweet/?text=Socket%20sharding%20in%20Linux%20example%20with%20Go&url=https%3a%2f%2fwww.kungfudev.com%2fposts%2fsocket-sharding-go%2f&hashtags=linux%2cgo%2csockets"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Socket sharding in Linux example with Go on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fwww.kungfudev.com%2fposts%2fsocket-sharding-go%2f&title=Socket%20sharding%20in%20Linux%20example%20with%20Go&summary=Socket%20sharding%20in%20Linux%20example%20with%20Go&source=https%3a%2f%2fwww.kungfudev.com%2fposts%2fsocket-sharding-go%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Socket sharding in Linux example with Go on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fwww.kungfudev.com%2fposts%2fsocket-sharding-go%2f&title=Socket%20sharding%20in%20Linux%20example%20with%20Go"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Socket sharding in Linux example with Go on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwww.kungfudev.com%2fposts%2fsocket-sharding-go%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Socket sharding in Linux example with Go on whatsapp" href="https://api.whatsapp.com/send?text=Socket%20sharding%20in%20Linux%20example%20with%20Go%20-%20https%3a%2f%2fwww.kungfudev.com%2fposts%2fsocket-sharding-go%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Socket sharding in Linux example with Go on telegram" href="https://telegram.me/share/url?text=Socket%20sharding%20in%20Linux%20example%20with%20Go&url=https%3a%2f%2fwww.kungfudev.com%2fposts%2fsocket-sharding-go%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://www.kungfudev.com>KungFu Developer</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>
<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>My introduction to Blockchain - Merkle tree in go | KungFu Dev</title><meta name=keywords content="go,blockchain,ethereum,bitcoin"><meta name=description content="A couple of months ago, I started playing/developing around the Blockchain, given the Hype it was having lately throughout the crypto space with cryptocurrencies and all the incredible possible applications thanks to the implementation of smart contracts such as NFT collections, NFT games and DAO. I have always been very interested in distributed systems, and the Blockchain is a distributed system in its purest form.
It all started with one of the most popular games, which was applying this new concept of Play2Earn, where the game&rsquo;s assets were Tokens (ERC-721), which the players owned and generated profit while playing with them."><meta name=author content="Me"><link rel=canonical href=https://www.kungfudev.com/posts/my-introduction-to-blockchain-and-merkle-tree/><link crossorigin=anonymous href=/assets/css/stylesheet.min.ed52a04cba0843fef8297e018b15e8a32a989ea4415133cb8bf77414d3815f7b.css integrity="sha256-7VKgTLoIQ/74KX4BixXooyqYnqRBUTPLi/d0FNOBX3s=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.4dcb3c4f38462f66c6b6137227726f5543cb934cca9788f041c087e374491df2.js integrity="sha256-Tcs8TzhGL2bGthNyJ3JvVUPLk0zKl4jwQcCH43RJHfI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://www.kungfudev.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.kungfudev.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.kungfudev.com/favicon-32x32.png><link rel=apple-touch-icon href=https://www.kungfudev.com/apple-touch-icon.png><link rel=mask-icon href=https://www.kungfudev.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://www.kungfudev.com/posts/my-introduction-to-blockchain-and-merkle-tree/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="My introduction to Blockchain - Merkle tree in go"><meta property="og:description" content="A couple of months ago, I started playing/developing around the Blockchain, given the Hype it was having lately throughout the crypto space with cryptocurrencies and all the incredible possible applications thanks to the implementation of smart contracts such as NFT collections, NFT games and DAO. I have always been very interested in distributed systems, and the Blockchain is a distributed system in its purest form.
It all started with one of the most popular games, which was applying this new concept of Play2Earn, where the game&rsquo;s assets were Tokens (ERC-721), which the players owned and generated profit while playing with them."><meta property="og:type" content="article"><meta property="og:url" content="https://www.kungfudev.com/posts/my-introduction-to-blockchain-and-merkle-tree/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-04-21T00:00:00+00:00"><meta property="article:modified_time" content="2022-04-21T00:00:00+00:00"><meta property="og:site_name" content="I'm Kung Fu Dev"><meta name=twitter:card content="summary"><meta name=twitter:title content="My introduction to Blockchain - Merkle tree in go"><meta name=twitter:description content="A couple of months ago, I started playing/developing around the Blockchain, given the Hype it was having lately throughout the crypto space with cryptocurrencies and all the incredible possible applications thanks to the implementation of smart contracts such as NFT collections, NFT games and DAO. I have always been very interested in distributed systems, and the Blockchain is a distributed system in its purest form.
It all started with one of the most popular games, which was applying this new concept of Play2Earn, where the game&rsquo;s assets were Tokens (ERC-721), which the players owned and generated profit while playing with them."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://www.kungfudev.com/posts/"},{"@type":"ListItem","position":3,"name":"My introduction to Blockchain - Merkle tree in go","item":"https://www.kungfudev.com/posts/my-introduction-to-blockchain-and-merkle-tree/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"My introduction to Blockchain - Merkle tree in go","name":"My introduction to Blockchain - Merkle tree in go","description":"A couple of months ago, I started playing/developing around the Blockchain, given the Hype it was having lately throughout the crypto space with cryptocurrencies and all the incredible possible applications thanks to the implementation of smart contracts such as NFT collections, NFT games and DAO. I have always been very interested in distributed systems, and the Blockchain is a distributed system in its purest form.\nIt all started with one of the most popular games, which was applying this new concept of Play2Earn, where the game\u0026rsquo;s assets were Tokens (ERC-721), which the players owned and generated profit while playing with them.","keywords":["go","blockchain","ethereum","bitcoin"],"articleBody":"A couple of months ago, I started playing/developing around the Blockchain, given the Hype it was having lately throughout the crypto space with cryptocurrencies and all the incredible possible applications thanks to the implementation of smart contracts such as NFT collections, NFT games and DAO. I have always been very interested in distributed systems, and the Blockchain is a distributed system in its purest form.\nIt all started with one of the most popular games, which was applying this new concept of Play2Earn, where the game’s assets were Tokens (ERC-721), which the players owned and generated profit while playing with them. They could also trade them with other players through the market that the platform offered, my interest was triggered when I found certain transactions in the market where there were players who bought these assets for a price below the average and then resold them for profit.\nAfter noticing this, I contacted a great colleague and friend since this represented two exciting benefits: first, to learn about this technology that had been talked about for years (still, neither of us had had the opportunity or interest to get into it so far); and second, it presented an actual use case that could also have an economic benefit. What a great incentive!\nWe started with simple iterations. We created a Bot that listened to the events and transactions of the particular Blockchain that we were interested in. Every time we found a transaction in which we could make a profit, we decided to participate. Obviously, we were not the only ones participating, so we failed most of the transactions, given that others were much faster than us. As the days passed, the more we investigated, the more we learned, and we were making more efficient implementations. We stopped using public nodes and deployed multiple nodes with a modified protocol version.\nThe Blockchain was an Ethereum fork, so we modified the implementation of the protocol (which is written in Go, and also my favourite language) to run our Bots as part of our internal implementation to be a bit faster. In this way, we end up doing Front-running of the transactions and gaining many more opportunities.\n Front running is the act of placing a transaction in a queue with the knowledge of a future transaction. https://coinmarketcap.com/alexandria/glossary/front-running\n In short, all this led me to be more involved in the whole topic of Blockchain development in recent weeks, and that is why I decided to learn a little more in-depth and share it with you while I do it. So the idea is that I’ll be posting little articles about technologies involved in everything related to Blockchain, anything that I find interesting and that might be interesting for you too.\nTo not bore you anymore with this introduction, in this first article, I want to talk about something that is a fundamental part of the blockchain, such as the Merkle tree, and one straightforward implementation in Go. This article assumes you have a basic understanding of cryptographic hash functions and basic binary tree algorithms.\nWhat is a Merkle Tree? A Merkle tree or hash tree is a binary tree where a node can only have zero, one, or two children. Every leaf node is labelled with the cryptographic hash of a data block (for example, a Blockchain transaction), and every node that is not a leaf (called a branch or inner node) is labelled with the cryptographic hash of the labels of its child nodes. The tree is complete when there is a single node called the Merkle root.\nThanks to this design, this structure achieves the following properties:\n Easy to verify data integrity because the root hash (the Merkle root) will change if any of the data changes. A single hash value, the Merkle root, represents all data blocks. Easy to verify the inclusion of a piece of data into the tree using the Merkle proof.  Something interesting to note about the construction of a Merkle tree is that since it is a binary tree and its branches are the combinations of the child nodes then, what happens if we have an odd number of leaf nodes? What happens if we have an odd number of branches nodes?\nWhen building a Merkle tree, the simple answer is that if we have an odd number of nodes at a particular level, we must duplicate the last node to concatenate with itself.\nSuppose a user knows the root hash of the Merkle tree and wants to check whether the tree does indeed contain a specific piece of data, such as a transaction. In that case, he can do it by using just one path through the Merkle tree, which is proportional to the log2 of the number of leaf nodes rather than the total number of leaf nodes.\nFor example, following the diagram above, we can see how users can check the integrity of the L3 block or if it is present in the tree. If they know the root hash and are provided with Hash 1-1 and Hash 0, they can do it by following the next steps:\n Users first get the hash of the data block they want to check, in this case, the L3 block: Hash(L3), to get the Hash 1-0. Then they must combine the result with the next provided hash, which must be the node’s hash that is its peer. In this case, it would be Hash(Hash 1-0, Hash 1-1) and so on until we get the Merkle root. Finally, they only need to check that the obtained root hash equals the previously known root hash. If the hashes are the same, the L3 block belongs to the tree, and its data has not been altered. Otherwise, L3 is not in the tree or its data was changed.  As can be seen, a Merkle tree allows rapid validation and provides a robust security system since if any of the blocks is modified, the result of its hash is different. Therefore, combining its hash with the subsequent hashes will produce a different root hash than the known one.\nA Merkle tree is used in many computer applications. In Bitcoin and other cryptocurrencies, Merkle trees are especially used to maintain the state of the blockchain efficiently and securely.\nOn average, there are 500 transactions in a Bitcoin block. Without this data structure, each user/client who wants to check if one transaction is within a specific block or its integrity would have to request and download the 500 transactions to prove it. While using a Merkle tree implementation, they only need to download the path of nine nodes ceil(log2(500)) = 9 of the specific transaction and execute the process discussed before. With this, you can check the integrity of the transaction.\nEven if the block contained 1M transactions, it would only need a path with 20 nodes to be able to perform validation.\nAs you can see, this data structure is compelling and is used in various systems such as:\n Version control systems, for example, Git. File system in P2P. Databases. Blockchain.  Merkle en Go An easy way to build this tree is to use a pointer-based strategy. With pointers, we can easily see the relationship of nodes to their children and parents and use this knowledge to calculate their hashes correctly. Also, these relations will help us to build the path to prove a piece of data.\nAs we already know, in this type of tree, the leaf nodes are hashes of the data we want to build the tree, so we must make it from the leaves to the root using a layered construction algorithm from the bottom up.\nWe will start with two relatively simple structures, in which we will store the tree and the nodes of the tree with their respective values.\ntype Tree struct { Root *Node Leaves []*Node h Hasher } type Node struct { Parent *Node Left *Node Right *Node Hash []byte } The NewFromHashes function will help us create a tree from an array of hashes, as we already know the leaf nodes of this structure are hashes of the desired information.\nfunc NewFromHashes(hashes [][]byte, h Hasher) *Tree { t := \u0026Tree{ Leaves: make([]*Node, 0, len(hashes)), h: h, } // Add leaf nodes. \tfor _, h := range hashes { t.Leaves = append(t.Leaves, \u0026Node{Hash: h}) } t.Root = t.buildRoot() return t } The next one will iterate through each layer of nodes to form their relationships until it reaches the root node.\nfunc (t *Tree) buildRoot() *Node { nodes := t.Leaves // We are iterating until we reach a single node, which will be our root. \tfor len(nodes)  1 { var parents []*Node // Having an odd number of nodes at this level, we will duplicate the last node to concatenate it with itself. \tif len(nodes)%2 != 0 { nodes = append(nodes, nodes[len(nodes)-1]) } // Pairing nodes to build a parent from the pair \tfor i := 0; i  len(nodes); i += 2 { n := \u0026Node{ Left: nodes[i], Right: nodes[i+1], // Compute the hash of the new node, which will be the combination of its children's hashes. \tHash: t.h.Hash(nodes[i].Hash, nodes[i+1].Hash), } parents = append(parents, n) nodes[i].Parent, nodes[i+1].Parent = n, n } // Once all possible pairs are processed, the parents become the children, and we start all over again. \tnodes = parents } return nodes[0] } The GetProof function receives as a parameter the hash of the data/transaction that we want to verify and will return the hashes of the nodes that are needed to validate its integrity. Using the relation between nodes, we can retrieve those nodes easily.\nI added some explanatory comments which I think may clarify the way we get the proof using pointers.\nfunc (t *Tree) GetProof(hash []byte) ([][]byte, []int, error) { var ( path [][]byte idxs []int ) // Find the leaf node for the specific hash. \tfor _, currentNode := range t.Leaves { if bytes.Equal(currentNode.Hash, hash) { // After finding the node, we will scale the tree using the relationship of the nodes to their parent nodes. \tparent := currentNode.Parent for parent != nil { // If the current node is the left child, we need the right child to calculate the parent hash \t// for the proof and vice versa. \t// i.e: \t// If CurrentNode == Left ; ParentHash = (CurrentNode.Hash, RightChild.Hash) \t// If CurrentNode == Right ; ParentHash = (LeftChild.Hash, CurrentNode.Hash) \t// So we have to add the corresponding hash to the path, and in idxs, we save the hash's position 0 \t// for left and 1 for right. In this way, when we want to verify the proof, we can know if \t// the given hash is the left o right child. \tif bytes.Equal(currentNode.Hash, parent.Left.Hash) { path = append(path, parent.Right.Hash) idxs = append(idxs, 1) } else { path = append(path, parent.Left.Hash) idxs = append(idxs, 0) } currentNode = parent parent = currentNode.Parent } return path, idxs, nil } } return path, idxs, errors.New(\"hash does not belong to the tree\") } If you go to the repository, you can find the function to verify the proof, and you will also find a complete example of this simple implementation. Github Repo.\npackage main import ( \"crypto/sha256\" \"fmt\" \"github.com/douglasmakey/mktree\" ) type transaction struct { from string to string value string } func hashTrx(t transaction) []byte { h := sha256.New() h.Write([]byte(fmt.Sprintf(\"%v\", t))) return h.Sum(nil) } func main() { trx1 := transaction{from: \"mike\", to: \"bob\", value: \"100\"} trx2 := transaction{from: \"bob\", to: \"douglas\", value: \"250\"} trx3 := transaction{from: \"alice\", to: \"john\", value: \"100\"} trx4 := transaction{from: \"vitalik\", to: \"elon\", value: \"10000\"} data := [][]byte{ hashTrx(trx1), hashTrx(trx2), hashTrx(trx3), hashTrx(trx4), } // Create and verify the tree. \tt := mktree.NewFromHashes(data, mktree.DefaultShaHasher) fmt.Println(\"Hex: \", t.Root.Hex()) // Getting the proof of the first transaction and verify it. \tproof, idxs, err := t.GetProof(hashTrx(trx1)) if err != nil { panic(err) } fmt.Printf(\"Verify proof of trx1: %+v \\n\", trx1) p := mktree.VerifyProof(t.Root.Hash, hashTrx(trx1), proof, idxs, mktree.DefaultShaHasher) fmt.Println(\"Proof integrity: \", p) // Change trx1 and try to verify it with the original proof. \ttrx1.value = \"1000\" fmt.Printf(\"Verify proof of trx1: %+v \\n\", trx1) p = mktree.VerifyProof(t.Root.Hash, hashTrx(trx1), proof, idxs, mktree.DefaultShaHasher) fmt.Println(\"Proof integrity with a change trx: \", p) // Modifying the second transaction to send money to me. \ttrx5 := transaction{from: \"vitalik\", to: \"douglas\", value: \"10000\"} t.Leaves[1].Hash = hashTrx(trx5) // We are going to verify the integrity of the tree after the modification \tfmt.Println(\"Tree integrity: \", t.Verify()) } I hope you enjoyed the article. Thanks for your time, and any feedback is always welcomed ❤️.\nLinks:\n https://www.geeksforgeeks.org/binary-tree-data-structure/ https://en.wikipedia.org/wiki/Cryptographic_hash_function https://en.wikipedia.org/wiki/Merkle_tree https://en.bitcoinwiki.org/wiki/Merkle_tree https://en.bitcoin.it/wiki/Protocol_documentation#Merkle_Trees https://cointelegraph.com/explained/what-is-front-running-in-crypto-and-nft-trading  ","wordCount":"2097","inLanguage":"en","datePublished":"2022-04-21T00:00:00Z","dateModified":"2022-04-21T00:00:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.kungfudev.com/posts/my-introduction-to-blockchain-and-merkle-tree/"},"publisher":{"@type":"Organization","name":"KungFu Dev","logo":{"@type":"ImageObject","url":"https://www.kungfudev.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.kungfudev.com accesskey=h title="KungFu Dev (Alt + H)">KungFu Dev</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://www.kungfudev.com/es/ title=Español aria-label=Español>Es</a></li></ul></span></div><ul id=menu><li><a href=https://www.kungfudev.com/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://www.kungfudev.com/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://www.kungfudev.com/archives/ title=Archives><span>Archives</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://www.kungfudev.com>Home</a>&nbsp;»&nbsp;<a href=https://www.kungfudev.com/posts/>Posts</a></div><h1 class=post-title>My introduction to Blockchain - Merkle tree in go</h1><div class=post-meta><span title="2022-04-21 00:00:00 +0000 UTC">April 21, 2022</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;Me</div></header><div class=post-content><p>A couple of months ago, I started playing/developing around the Blockchain, given the Hype it was having lately throughout the crypto space with cryptocurrencies and all the incredible possible applications thanks to the implementation of smart contracts such as NFT collections, NFT games and DAO. I have always been very interested in distributed systems, and the Blockchain is a distributed system in its purest form.</p><p>It all started with one of the most popular games, which was applying this new concept of Play2Earn, where the game&rsquo;s assets were Tokens (ERC-721), which the players owned and generated profit while playing with them. They could also trade them with other players through the market that the platform offered, my interest was triggered when I found certain transactions in the market where there were players who bought these assets for a price below the average and then resold them for profit.</p><p>After noticing this, I contacted a great colleague and friend since this represented two exciting benefits: first, to learn about this technology that had been talked about for years (still, neither of us had had the opportunity or interest to get into it so far); and second, it presented an actual use case that could also have an economic benefit. What a great incentive!</p><p>We started with simple iterations. We created a Bot that listened to the events and transactions of the particular Blockchain that we were interested in. Every time we found a transaction in which we could make a profit, we decided to participate. Obviously, we were not the only ones participating, so we failed most of the transactions, given that others were much faster than us. As the days passed, the more we investigated, the more we learned, and we were making more efficient implementations. We stopped using public nodes and deployed multiple nodes with a modified protocol version.</p><p>The Blockchain was an Ethereum fork, so we modified the implementation of the protocol (which is written in Go, and also my favourite language) to run our Bots as part of our internal implementation to be a bit faster. In this way, we end up doing Front-running of the transactions and gaining many more opportunities.</p><blockquote><p>Front running is the act of placing a transaction in a queue with the knowledge of a future transaction.
<a href=https://coinmarketcap.com/alexandria/glossary/front-running>https://coinmarketcap.com/alexandria/glossary/front-running</a></p></blockquote><p>In short, all this led me to be more involved in the whole topic of Blockchain development in recent weeks, and that is why I decided to learn a little more in-depth and share it with you while I do it. So the idea is that I&rsquo;ll be posting little articles about technologies involved in everything related to Blockchain, anything that I find interesting and that might be interesting for you too.</p><p>To not bore you anymore with this introduction, in this first article, I want to talk about something that is a fundamental part of the blockchain, such as the Merkle tree, and one straightforward implementation in Go. This article assumes you have a basic understanding of cryptographic hash functions and basic binary tree algorithms.</p><h2 id=what-is-a-merkle-tree>What is a Merkle Tree?<a hidden class=anchor aria-hidden=true href=#what-is-a-merkle-tree>#</a></h2><p>A Merkle tree or hash tree is a binary tree where a node can only have zero, one, or two children. Every leaf node is labelled with the cryptographic hash of a data block (for example, a Blockchain transaction), and every node that is not a leaf (called a branch or inner node) is labelled with the cryptographic hash of the labels of its child nodes. The tree is complete when there is a single node called the Merkle root.</p><p>Thanks to this design, this structure achieves the following properties:</p><ul><li>Easy to verify data integrity because the root hash (the Merkle root) will change if any of the data changes.</li><li>A single hash value, the Merkle root, represents all data blocks.</li><li>Easy to verify the inclusion of a piece of data into the tree using the Merkle proof.</li></ul><p>Something interesting to note about the construction of a Merkle tree is that since it is a binary tree and its branches are the combinations of the child nodes then, what happens if we have an odd number of leaf nodes? What happens if we have an odd number of branches nodes?</p><p>When building a Merkle tree, the simple answer is that if we have an odd number of nodes at a particular level, we must duplicate the last node to concatenate with itself.</p><p><img loading=lazy src=/img/merkle_tree.png alt></p><p>Suppose a user knows the root hash of the Merkle tree and wants to check whether the tree does indeed contain a specific piece of data, such as a transaction. In that case, he can do it by using just one path through the Merkle tree, which is proportional to the <code>log2</code> of the number of leaf nodes rather than the total number of leaf nodes.</p><p>For example, following the diagram above, we can see how users can check the integrity of the <code>L3</code> block or if it is present in the tree. If they know the <code>root hash</code> and are provided with <code>Hash 1-1</code> and <code>Hash 0</code>, they can do it by following the next steps:</p><ul><li>Users first get the hash of the data block they want to check, in this case, the <code>L3</code> block: <code>Hash(L3)</code>, to get the <code>Hash 1-0</code>.</li><li>Then they must combine the result with the next provided hash, which must be the node&rsquo;s hash that is its peer. In this case, it would be <code>Hash(Hash 1-0, Hash 1-1)</code> and so on until we get the Merkle root.</li><li>Finally, they only need to check that the obtained root hash equals the previously known root hash. If the hashes are the same, the <code>L3</code> block belongs to the tree, and its data has not been altered. Otherwise, <code>L3</code> is not in the tree or its data was changed.</li></ul><p><img loading=lazy src=/img/proof.png alt></p><p>As can be seen, a Merkle tree allows rapid validation and provides a robust security system since if any of the blocks is modified, the result of its hash is different. Therefore, combining its hash with the subsequent hashes will produce a different root hash than the known one.</p><p>A Merkle tree is used in many computer applications. In Bitcoin and other cryptocurrencies, Merkle trees are especially used to maintain the state of the blockchain efficiently and securely.</p><p>On average, there are 500 transactions in a Bitcoin block. Without this data structure, each user/client who wants to check if one transaction is within a specific block or its integrity would have to request and download the 500 transactions to prove it. While using a Merkle tree implementation, they only need to download the path of nine nodes <code>ceil(log2(500)) = 9</code> of the specific transaction and execute the process discussed before. With this, you can check the integrity of the transaction.</p><p>Even if the block contained 1M transactions, it would only need a path with 20 nodes to be able to perform validation.</p><p>As you can see, this data structure is compelling and is used in various systems such as:</p><ul><li>Version control systems, for example, Git.</li><li>File system in P2P.</li><li>Databases.</li><li>Blockchain.</li></ul><h2 id=merkle-en-go>Merkle en Go<a hidden class=anchor aria-hidden=true href=#merkle-en-go>#</a></h2><p>An easy way to build this tree is to use a pointer-based strategy. With pointers, we can easily see the relationship of nodes to their children and parents and use this knowledge to calculate their hashes correctly. Also, these relations will help us to build the path to prove a piece of data.</p><p>As we already know, in this type of tree, the leaf nodes are hashes of the data we want to build the tree, so we must make it from the leaves to the root using a layered construction algorithm from the bottom up.</p><p>We will start with two relatively simple structures, in which we will store the tree and the nodes of the tree with their respective values.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Tree</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>Root</span>   <span class=o>*</span><span class=nx>Node</span>
</span></span><span class=line><span class=cl>	<span class=nx>Leaves</span> <span class=p>[]</span><span class=o>*</span><span class=nx>Node</span>
</span></span><span class=line><span class=cl>	<span class=nx>h</span>      <span class=nx>Hasher</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Node</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>Parent</span> <span class=o>*</span><span class=nx>Node</span>
</span></span><span class=line><span class=cl>	<span class=nx>Left</span>   <span class=o>*</span><span class=nx>Node</span>
</span></span><span class=line><span class=cl>	<span class=nx>Right</span>  <span class=o>*</span><span class=nx>Node</span>
</span></span><span class=line><span class=cl>	<span class=nx>Hash</span>   <span class=p>[]</span><span class=kt>byte</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The <code>NewFromHashes</code> function will help us create a tree from an array of hashes, as we already know the leaf nodes of this structure are hashes of the desired information.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>NewFromHashes</span><span class=p>(</span><span class=nx>hashes</span> <span class=p>[][]</span><span class=kt>byte</span><span class=p>,</span> <span class=nx>h</span> <span class=nx>Hasher</span><span class=p>)</span> <span class=o>*</span><span class=nx>Tree</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>t</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>Tree</span><span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>Leaves</span><span class=p>:</span> <span class=nb>make</span><span class=p>([]</span><span class=o>*</span><span class=nx>Node</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>hashes</span><span class=p>)),</span>
</span></span><span class=line><span class=cl>		<span class=nx>h</span><span class=p>:</span>      <span class=nx>h</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Add leaf nodes.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>h</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>hashes</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>t</span><span class=p>.</span><span class=nx>Leaves</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>Leaves</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>Node</span><span class=p>{</span><span class=nx>Hash</span><span class=p>:</span> <span class=nx>h</span><span class=p>})</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>t</span><span class=p>.</span><span class=nx>Root</span> <span class=p>=</span> <span class=nx>t</span><span class=p>.</span><span class=nf>buildRoot</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>t</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The next one will iterate through each layer of nodes to form their relationships until it reaches the root node.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>Tree</span><span class=p>)</span> <span class=nf>buildRoot</span><span class=p>()</span> <span class=o>*</span><span class=nx>Node</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>nodes</span> <span class=o>:=</span> <span class=nx>t</span><span class=p>.</span><span class=nx>Leaves</span>
</span></span><span class=line><span class=cl>	<span class=c1>// We are iterating until we reach a single node, which will be our root.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>for</span> <span class=nb>len</span><span class=p>(</span><span class=nx>nodes</span><span class=p>)</span> <span class=p>&gt;</span> <span class=mi>1</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=kd>var</span> <span class=nx>parents</span> <span class=p>[]</span><span class=o>*</span><span class=nx>Node</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=c1>// Having an odd number of nodes at this level, we will duplicate the last node to concatenate it with itself.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>nodes</span><span class=p>)</span><span class=o>%</span><span class=mi>2</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>nodes</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>nodes</span><span class=p>,</span> <span class=nx>nodes</span><span class=p>[</span><span class=nb>len</span><span class=p>(</span><span class=nx>nodes</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>])</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=c1>// Pairing nodes to build a parent from the pair
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>nodes</span><span class=p>);</span> <span class=nx>i</span> <span class=o>+=</span> <span class=mi>2</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>n</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>Node</span><span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>Left</span><span class=p>:</span>  <span class=nx>nodes</span><span class=p>[</span><span class=nx>i</span><span class=p>],</span>
</span></span><span class=line><span class=cl>				<span class=nx>Right</span><span class=p>:</span> <span class=nx>nodes</span><span class=p>[</span><span class=nx>i</span><span class=o>+</span><span class=mi>1</span><span class=p>],</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>				<span class=c1>// Compute the hash of the new node, which will be the combination of its children&#39;s hashes.
</span></span></span><span class=line><span class=cl><span class=c1></span>				<span class=nx>Hash</span><span class=p>:</span> <span class=nx>t</span><span class=p>.</span><span class=nx>h</span><span class=p>.</span><span class=nf>Hash</span><span class=p>(</span><span class=nx>nodes</span><span class=p>[</span><span class=nx>i</span><span class=p>].</span><span class=nx>Hash</span><span class=p>,</span> <span class=nx>nodes</span><span class=p>[</span><span class=nx>i</span><span class=o>+</span><span class=mi>1</span><span class=p>].</span><span class=nx>Hash</span><span class=p>),</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>			<span class=nx>parents</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>parents</span><span class=p>,</span> <span class=nx>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=nx>nodes</span><span class=p>[</span><span class=nx>i</span><span class=p>].</span><span class=nx>Parent</span><span class=p>,</span> <span class=nx>nodes</span><span class=p>[</span><span class=nx>i</span><span class=o>+</span><span class=mi>1</span><span class=p>].</span><span class=nx>Parent</span> <span class=p>=</span> <span class=nx>n</span><span class=p>,</span> <span class=nx>n</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Once all possible pairs are processed, the parents become the children, and we start all over again.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>nodes</span> <span class=p>=</span> <span class=nx>parents</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>nodes</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The <code>GetProof</code> function receives as a parameter the hash of the data/transaction that we want to verify and will return the hashes of the nodes that are needed to validate its integrity. Using the relation between nodes, we can retrieve those nodes easily.</p><p>I added some explanatory comments which I think may clarify the way we get the proof using pointers.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>Tree</span><span class=p>)</span> <span class=nf>GetProof</span><span class=p>(</span><span class=nx>hash</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=p>([][]</span><span class=kt>byte</span><span class=p>,</span> <span class=p>[]</span><span class=kt>int</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>		<span class=nx>path</span> <span class=p>[][]</span><span class=kt>byte</span>
</span></span><span class=line><span class=cl>		<span class=nx>idxs</span> <span class=p>[]</span><span class=kt>int</span>
</span></span><span class=line><span class=cl>	<span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Find the leaf node for the specific hash.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>currentNode</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>t</span><span class=p>.</span><span class=nx>Leaves</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>bytes</span><span class=p>.</span><span class=nf>Equal</span><span class=p>(</span><span class=nx>currentNode</span><span class=p>.</span><span class=nx>Hash</span><span class=p>,</span> <span class=nx>hash</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=c1>// After finding the node, we will scale the tree using the relationship of the nodes to their parent nodes.
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=nx>parent</span> <span class=o>:=</span> <span class=nx>currentNode</span><span class=p>.</span><span class=nx>Parent</span>
</span></span><span class=line><span class=cl>			<span class=k>for</span> <span class=nx>parent</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=c1>// If the current node is the left child, we need the right child to calculate the parent hash
</span></span></span><span class=line><span class=cl><span class=c1></span>				<span class=c1>// for the proof and vice versa.
</span></span></span><span class=line><span class=cl><span class=c1></span>				<span class=c1>// i.e:
</span></span></span><span class=line><span class=cl><span class=c1></span>				<span class=c1>// If CurrentNode == Left ; ParentHash = (CurrentNode.Hash, RightChild.Hash)
</span></span></span><span class=line><span class=cl><span class=c1></span>				<span class=c1>// If CurrentNode == Right ; ParentHash = (LeftChild.Hash, CurrentNode.Hash)
</span></span></span><span class=line><span class=cl><span class=c1></span>				<span class=c1>// So we have to add the corresponding hash to the path, and in idxs, we save the hash&#39;s position 0
</span></span></span><span class=line><span class=cl><span class=c1></span>				<span class=c1>// for left and 1 for right. In this way, when we want to verify the proof, we can know if
</span></span></span><span class=line><span class=cl><span class=c1></span>				<span class=c1>// the given hash is the left o right child.
</span></span></span><span class=line><span class=cl><span class=c1></span>				<span class=k>if</span> <span class=nx>bytes</span><span class=p>.</span><span class=nf>Equal</span><span class=p>(</span><span class=nx>currentNode</span><span class=p>.</span><span class=nx>Hash</span><span class=p>,</span> <span class=nx>parent</span><span class=p>.</span><span class=nx>Left</span><span class=p>.</span><span class=nx>Hash</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>					<span class=nx>path</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>path</span><span class=p>,</span> <span class=nx>parent</span><span class=p>.</span><span class=nx>Right</span><span class=p>.</span><span class=nx>Hash</span><span class=p>)</span>
</span></span><span class=line><span class=cl>					<span class=nx>idxs</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>idxs</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>				<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>					<span class=nx>path</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>path</span><span class=p>,</span> <span class=nx>parent</span><span class=p>.</span><span class=nx>Left</span><span class=p>.</span><span class=nx>Hash</span><span class=p>)</span>
</span></span><span class=line><span class=cl>					<span class=nx>idxs</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>idxs</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>				<span class=p>}</span>
</span></span><span class=line><span class=cl>				<span class=nx>currentNode</span> <span class=p>=</span> <span class=nx>parent</span>
</span></span><span class=line><span class=cl>				<span class=nx>parent</span> <span class=p>=</span> <span class=nx>currentNode</span><span class=p>.</span><span class=nx>Parent</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=nx>path</span><span class=p>,</span> <span class=nx>idxs</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>path</span><span class=p>,</span> <span class=nx>idxs</span><span class=p>,</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=s>&#34;hash does not belong to the tree&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>If you go to the repository, you can find the function to verify the proof, and you will also find a complete example of this simple implementation. <a href=https://github.com/douglasmakey/mktree>Github Repo</a>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;crypto/sha256&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=s>&#34;github.com/douglasmakey/mktree&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>transaction</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>from</span>  <span class=kt>string</span>
</span></span><span class=line><span class=cl>	<span class=nx>to</span>    <span class=kt>string</span>
</span></span><span class=line><span class=cl>	<span class=nx>value</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>hashTrx</span><span class=p>(</span><span class=nx>t</span> <span class=nx>transaction</span><span class=p>)</span> <span class=p>[]</span><span class=kt>byte</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>h</span> <span class=o>:=</span> <span class=nx>sha256</span><span class=p>.</span><span class=nf>New</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>h</span><span class=p>.</span><span class=nf>Write</span><span class=p>([]</span><span class=nb>byte</span><span class=p>(</span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Sprintf</span><span class=p>(</span><span class=s>&#34;%v&#34;</span><span class=p>,</span> <span class=nx>t</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>h</span><span class=p>.</span><span class=nf>Sum</span><span class=p>(</span><span class=kc>nil</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>trx1</span> <span class=o>:=</span> <span class=nx>transaction</span><span class=p>{</span><span class=nx>from</span><span class=p>:</span> <span class=s>&#34;mike&#34;</span><span class=p>,</span> <span class=nx>to</span><span class=p>:</span> <span class=s>&#34;bob&#34;</span><span class=p>,</span> <span class=nx>value</span><span class=p>:</span> <span class=s>&#34;100&#34;</span><span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>trx2</span> <span class=o>:=</span> <span class=nx>transaction</span><span class=p>{</span><span class=nx>from</span><span class=p>:</span> <span class=s>&#34;bob&#34;</span><span class=p>,</span> <span class=nx>to</span><span class=p>:</span> <span class=s>&#34;douglas&#34;</span><span class=p>,</span> <span class=nx>value</span><span class=p>:</span> <span class=s>&#34;250&#34;</span><span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>trx3</span> <span class=o>:=</span> <span class=nx>transaction</span><span class=p>{</span><span class=nx>from</span><span class=p>:</span> <span class=s>&#34;alice&#34;</span><span class=p>,</span> <span class=nx>to</span><span class=p>:</span> <span class=s>&#34;john&#34;</span><span class=p>,</span> <span class=nx>value</span><span class=p>:</span> <span class=s>&#34;100&#34;</span><span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>trx4</span> <span class=o>:=</span> <span class=nx>transaction</span><span class=p>{</span><span class=nx>from</span><span class=p>:</span> <span class=s>&#34;vitalik&#34;</span><span class=p>,</span> <span class=nx>to</span><span class=p>:</span> <span class=s>&#34;elon&#34;</span><span class=p>,</span> <span class=nx>value</span><span class=p>:</span> <span class=s>&#34;10000&#34;</span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>data</span> <span class=o>:=</span> <span class=p>[][]</span><span class=kt>byte</span><span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>hashTrx</span><span class=p>(</span><span class=nx>trx1</span><span class=p>),</span>
</span></span><span class=line><span class=cl>		<span class=nf>hashTrx</span><span class=p>(</span><span class=nx>trx2</span><span class=p>),</span>
</span></span><span class=line><span class=cl>		<span class=nf>hashTrx</span><span class=p>(</span><span class=nx>trx3</span><span class=p>),</span>
</span></span><span class=line><span class=cl>		<span class=nf>hashTrx</span><span class=p>(</span><span class=nx>trx4</span><span class=p>),</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Create and verify the tree.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>t</span> <span class=o>:=</span> <span class=nx>mktree</span><span class=p>.</span><span class=nf>NewFromHashes</span><span class=p>(</span><span class=nx>data</span><span class=p>,</span> <span class=nx>mktree</span><span class=p>.</span><span class=nx>DefaultShaHasher</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Hex: &#34;</span><span class=p>,</span> <span class=nx>t</span><span class=p>.</span><span class=nx>Root</span><span class=p>.</span><span class=nf>Hex</span><span class=p>())</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Getting the proof of the first transaction and verify it.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>proof</span><span class=p>,</span> <span class=nx>idxs</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>t</span><span class=p>.</span><span class=nf>GetProof</span><span class=p>(</span><span class=nf>hashTrx</span><span class=p>(</span><span class=nx>trx1</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nb>panic</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;Verify proof of trx1: %+v \n&#34;</span><span class=p>,</span> <span class=nx>trx1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>p</span> <span class=o>:=</span> <span class=nx>mktree</span><span class=p>.</span><span class=nf>VerifyProof</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>Root</span><span class=p>.</span><span class=nx>Hash</span><span class=p>,</span> <span class=nf>hashTrx</span><span class=p>(</span><span class=nx>trx1</span><span class=p>),</span> <span class=nx>proof</span><span class=p>,</span> <span class=nx>idxs</span><span class=p>,</span> <span class=nx>mktree</span><span class=p>.</span><span class=nx>DefaultShaHasher</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Proof integrity: &#34;</span><span class=p>,</span> <span class=nx>p</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Change trx1 and try to verify it with the original proof.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>trx1</span><span class=p>.</span><span class=nx>value</span> <span class=p>=</span> <span class=s>&#34;1000&#34;</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;Verify proof of trx1: %+v \n&#34;</span><span class=p>,</span> <span class=nx>trx1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>p</span> <span class=p>=</span> <span class=nx>mktree</span><span class=p>.</span><span class=nf>VerifyProof</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>Root</span><span class=p>.</span><span class=nx>Hash</span><span class=p>,</span> <span class=nf>hashTrx</span><span class=p>(</span><span class=nx>trx1</span><span class=p>),</span> <span class=nx>proof</span><span class=p>,</span> <span class=nx>idxs</span><span class=p>,</span> <span class=nx>mktree</span><span class=p>.</span><span class=nx>DefaultShaHasher</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Proof integrity with a change trx: &#34;</span><span class=p>,</span> <span class=nx>p</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Modifying the second transaction to send money to me.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>trx5</span> <span class=o>:=</span> <span class=nx>transaction</span><span class=p>{</span><span class=nx>from</span><span class=p>:</span> <span class=s>&#34;vitalik&#34;</span><span class=p>,</span> <span class=nx>to</span><span class=p>:</span> <span class=s>&#34;douglas&#34;</span><span class=p>,</span> <span class=nx>value</span><span class=p>:</span> <span class=s>&#34;10000&#34;</span><span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>t</span><span class=p>.</span><span class=nx>Leaves</span><span class=p>[</span><span class=mi>1</span><span class=p>].</span><span class=nx>Hash</span> <span class=p>=</span> <span class=nf>hashTrx</span><span class=p>(</span><span class=nx>trx5</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=c1>// We are going to verify the integrity of the tree after the modification
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Tree integrity: &#34;</span><span class=p>,</span> <span class=nx>t</span><span class=p>.</span><span class=nf>Verify</span><span class=p>())</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>I hope you enjoyed the article. Thanks for your time, and any feedback is always welcomed ❤️.</p><p>Links:</p><ul><li><a href=https://www.geeksforgeeks.org/binary-tree-data-structure/>https://www.geeksforgeeks.org/binary-tree-data-structure/</a></li><li><a href=https://en.wikipedia.org/wiki/Cryptographic_hash_function>https://en.wikipedia.org/wiki/Cryptographic_hash_function</a></li><li><a href=https://en.wikipedia.org/wiki/Merkle_tree>https://en.wikipedia.org/wiki/Merkle_tree</a></li><li><a href=https://en.bitcoinwiki.org/wiki/Merkle_tree>https://en.bitcoinwiki.org/wiki/Merkle_tree</a></li><li><a href=https://en.bitcoin.it/wiki/Protocol_documentation#Merkle_Trees>https://en.bitcoin.it/wiki/Protocol_documentation#Merkle_Trees</a></li><li><a href=https://cointelegraph.com/explained/what-is-front-running-in-crypto-and-nft-trading>https://cointelegraph.com/explained/what-is-front-running-in-crypto-and-nft-trading</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://www.kungfudev.com/tags/go/>go</a></li><li><a href=https://www.kungfudev.com/tags/blockchain/>blockchain</a></li><li><a href=https://www.kungfudev.com/tags/ethereum/>ethereum</a></li><li><a href=https://www.kungfudev.com/tags/bitcoin/>bitcoin</a></li></ul><nav class=paginav><a class=next href=https://www.kungfudev.com/posts/socket-sharding-go/><span class=title>Next Page »</span><br><span>Socket sharding in Linux example with Go</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share My introduction to Blockchain - Merkle tree in go on twitter" href="https://twitter.com/intent/tweet/?text=My%20introduction%20to%20Blockchain%20-%20Merkle%20tree%20in%20go&url=https%3a%2f%2fwww.kungfudev.com%2fposts%2fmy-introduction-to-blockchain-and-merkle-tree%2f&hashtags=go%2cblockchain%2cethereum%2cbitcoin"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share My introduction to Blockchain - Merkle tree in go on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fwww.kungfudev.com%2fposts%2fmy-introduction-to-blockchain-and-merkle-tree%2f&title=My%20introduction%20to%20Blockchain%20-%20Merkle%20tree%20in%20go&summary=My%20introduction%20to%20Blockchain%20-%20Merkle%20tree%20in%20go&source=https%3a%2f%2fwww.kungfudev.com%2fposts%2fmy-introduction-to-blockchain-and-merkle-tree%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share My introduction to Blockchain - Merkle tree in go on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fwww.kungfudev.com%2fposts%2fmy-introduction-to-blockchain-and-merkle-tree%2f&title=My%20introduction%20to%20Blockchain%20-%20Merkle%20tree%20in%20go"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share My introduction to Blockchain - Merkle tree in go on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwww.kungfudev.com%2fposts%2fmy-introduction-to-blockchain-and-merkle-tree%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share My introduction to Blockchain - Merkle tree in go on whatsapp" href="https://api.whatsapp.com/send?text=My%20introduction%20to%20Blockchain%20-%20Merkle%20tree%20in%20go%20-%20https%3a%2f%2fwww.kungfudev.com%2fposts%2fmy-introduction-to-blockchain-and-merkle-tree%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share My introduction to Blockchain - Merkle tree in go on telegram" href="https://telegram.me/share/url?text=My%20introduction%20to%20Blockchain%20-%20Merkle%20tree%20in%20go&url=https%3a%2f%2fwww.kungfudev.com%2fposts%2fmy-introduction-to-blockchain-and-merkle-tree%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer><div id=hyvor-talk-view></div><script type=text/javascript>var HYVOR_TALK_WEBSITE=6897,HYVOR_TALK_CONFIG={url:"https://www.kungfudev.com/posts/my-introduction-to-blockchain-and-merkle-tree/",id:6897}</script><script async type=text/javascript src=//talk.hyvor.com/web-api/embed.js></script></article></main><footer class=footer><span>&copy; 2022 <a href=https://www.kungfudev.com>KungFu Dev</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script src=https://getinsights.io/js/insights.js></script>
<script>insights.init("TnZvIwArM6FGkKwK"),insights.trackPages()</script></body></html>